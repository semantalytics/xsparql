/* This format can be fed to http://bottlecaps.de/rr/ui */

/* xQuery Non terminals */
/*[1]*/ module              ::= versionDecl? (libraryModule | mainModule)
/*[2]*/ versionDecl         ::= XQUERY VERSION stringliteral (ENCODING stringliteral)? separator
/*[3]*/ mainModule          ::= prolog queryBody
/*[4]*/ libraryModule       ::= moduleDecl prolog
/*[5]*/ moduleDecl          ::= MODULE NAMESPACE NCNAME EQUALS uriliteral separator
/*[6]*/ prolog              ::= baseDecl? (((defaultNamespaceDecl | namespaceDecl | setter | importa) separator    ) | prefixDecl)* ((varDecl | functionDecl | optionDecl) separator    )*
/*[7]*/ setter              ::= boundarySpaceDecl | defaultCollationDecl | baseURIDecl | constructionDecl | orderingModeDecl | emptyOrderDecl | copyNamespacesDecl
/*[8]*/ importa             ::= schemaImport | moduleImport
/*[9]*/ separator           ::= SEMICOLON
/*[10]*/ namespaceDecl       ::= DECLARE NAMESPACE NCNAME EQUALS QSTRING
/*[11]*/ boundarySpaceDecl   ::= DECLARE BOUNDARYSPACE (PRESERVE | STRIP)
/*[12]*/ defaultNamespaceDecl::= DECLARE DEFAULT (ELEMENT | FUNCTION) NAMESPACE QSTRING
/*[13]*/ optionDecl          ::= DECLARE OPTION qname stringliteral
/*[14]*/ orderingModeDecl    ::= DECLARE ORDERING (ORDERED | UNORDERED)
/*[15]*/ emptyOrderDecl      ::= DECLARE DEFAULT ORDER EMPTY (GREATEST | LEAST )
/*[16]*/ copyNamespacesDecl  ::= DECLARE     COPYNAMESPACES^ preserveMode COMMA     inheritMode
/*[17]*/ preserveMode        ::= PRESERVE | NOPRESERVE
/*[18]*/ inheritMode         ::= INHERIT | NOINHERIT
/*[19]*/ defaultCollationDecl::= DECLARE DEFAULT COLLATION uriliteral
/*[20]*/ baseURIDecl         ::= DECLARE BASEURI QSTRING
/*[21]*/ schemaImport        ::= IMPORT SCHEMA schemaPrefix? uriliteral (AT uriliteral (COMMA uriliteral)*)?
/*[22]*/ schemaPrefix        ::= NAMESPACE     NCNAME EQUALS     | DEFAULT ELEMENT     NAMESPACE    
/*[23]*/ moduleImport        ::= IMPORT MODULE (NAMESPACE NCNAME EQUALS)? uriliteral (AT uriliteral (COMMA uriliteral)*)?
/*[24]*/ varDecl             ::= DECLARE VARIABLE VAR typeDeclaration? ( ASSIGN exprSingle | EXTERNAL )
/*[25]*/ constructionDecl    ::= DECLARE CONSTRUCTION (STRIP | PRESERVE)
/*[26]*/ functionDecl        ::= DECLARE FUNCTION qname LPAR paramList? RPAR (AS sequenceType)? (enclosedExpr | EXTERNAL)
/*[27]*/ paramList           ::= param (COMMA     param)*
/*[28]*/ param               ::= VAR typeDeclaration?
/*[29]*/ enclosedExpr        ::= LCURLY     expr RCURLY    
/*[30]*/ queryBody           ::= exprSingle (COMMA exprSingle)*
/*[31]*/ expr                ::= exprSingle (COMMA     exprSingle)*
/*[32]*/ exprSingle          ::= flworExpr | quantifiedExpr | typeSwitchExpr | constructQuery | orExpr | ifExpr
/*[33]*/ flworExpr           ::= (CONSTRUCT constructTemplate) | (RETURN exprSingle) | forletClause
/*[34]*/ forletClause        ::= FOR     (sparqlForClause | sqlForClause | (xqueryForClause whereClause? orderByClause?)) | letClause whereClause? orderByClause?
/*[35]*/ sparqlForClause     ::= DISTINCT? sparqlVarOrFunction+ datasetClause* endpointClause? sWhereClause solutionmodifier valuesClause | DISTINCT? STAR datasetClause* endpointClause? sWhereClause solutionmodifier valuesClause
/*[36]*/ distinctOrReduced   ::= DISTINCT | REDUCED
/*[37]*/ endpointClause      ::= ENDPOINT sourceSelector
/*[38]*/ sparqlVarOrFunction ::= VAR | LPAR expression AS VAR RPAR
/*[39]*/ xqueryForClause     ::= singleForClause (COMMA     singleForClause)*
/*[40]*/ singleForClause     ::= VAR typeDeclaration? positionalVar? IN exprSingle
/*[41]*/ positionalVar       ::= AT     VAR
/*[42]*/ letClause           ::= LET     singleLetClause (COMMA     singleLetClause)*
/*[43]*/ singleLetClause     ::= VAR typeDeclaration? ASSIGN exprSingle
/*[44]*/ whereClause         ::= WHERE exprSingle
/*[45]*/ orderByClause       ::= ORDER BY orderSpecList | STABLE ORDER BY orderSpecList
/*[46]*/ orderSpecList       ::= orderSpec (COMMA orderSpec)*
/*[47]*/ orderSpec           ::= exprSingle orderModifier
/*[48]*/ orderModifier       ::= (ASCENDING | DESCENDING)? (EMPTY (GREATEST | LEAST))? (COLLATION uriliteral)?
/*[49]*/ quantifiedExpr      ::= (SOME | EVERY) VAR typeDeclaration? IN exprSingle (COMMA VAR typeDeclaration? IN exprSingle)* SATISFIES exprSingle
/*[50]*/ typeSwitchExpr      ::= TYPESWITCH^ LPAR     expr RPAR     caseClause+ DEFAULT     VAR? RETURN     exprSingle
/*[51]*/ caseClause          ::= CASE (VAR AS)? sequenceType RETURN exprSingle
/*[52]*/ ifExpr              ::= IF^ LPAR     expr RPAR     THEN     exprSingle ELSE     exprSingle
/*[53]*/ orExpr              ::= andExpr (OR^ andExpr)*
/*[54]*/ andExpr             ::= comparisonExpr (AND comparisonExpr)*
/*[55]*/ comparisonExpr      ::= ((valueComp^ | generalComp^ | nodeComp^) rangeExpr)?
/*[56]*/ rangeExpr           ::= additiveExpr (TO additiveExpr)?
/*[57]*/ additiveExpr        ::= multiplicativeExpr ((PLUS | MINUS) multiplicativeExpr)*
/*[58]*/ multiplicativeExpr  ::= unionExpr ((STAR | DIV | IDIV | MOD) unionExpr)*
/*[59]*/ unionExpr           ::= intersectExceptExpr ((UNION | UNIONSYMBOL) intersectExceptExpr)*
/*[60]*/ intersectExceptExpr ::= instanceOfExpr ((INTERSECT | EXCEPT) instanceOfExpr)*
/*[61]*/ instanceOfExpr      ::= treatExpr (INSTANCE OF sequenceType)?
/*[62]*/ treatExpr           ::= castableExpr (TREAT AS sequenceType)?
/*[63]*/ castableExpr        ::= castExpr (CASTABLE AS singleType)?
/*[64]*/ castExpr            ::= unaryExpr (CAST AS singleType)?
/*[65]*/ unaryExpr           ::= (MINUS | PLUS)* valueExpr
/*[66]*/ valueExpr           ::= pathExpr | validateExpr | extensionExpr
/*[67]*/ generalComp         ::= EQUALS | LESSTHAN | GREATERTHAN | LESSTHANEQUALS | GREATERTHANEQUALS | HAFENEQUALS
/*[68]*/ valueComp           ::= ( EQ | NE | LT | LE | GT | GE )
/*[69]*/ nodeComp            ::= ( LESSTHANLESSTHAN | GREATERTHANGREATERTHAN | IS )
/*[70]*/ validateExpr        ::= VALIDATE validationMode? LCURLY     expr RCURLY    
/*[71]*/ validationMode      ::= (LAX | STRICT)
/*[72]*/ extensionExpr       ::= LCURLY     expr? RCURLY    
/*[73]*/ pathExpr            ::= (SLASH SLASH) | (SLASH relativePathExpr) | SLASH | relativePathExpr
/*[74]*/ relativePathExpr    ::= stepExpr (SLASH SLASH? stepExpr)*
/*[75]*/ stepExpr            ::= filterExpr | axisStep
/*[76]*/ axisStep            ::= (reverseStep | forwardStep) predicateList
/*[77]*/ forwardStep         ::= forwardAxis nodeTest | abbrevForwardStep
/*[78]*/ forwardAxis         ::= CHILD COLONCOLON | DESCENDANT COLONCOLON | ATTRIBUTE COLONCOLON | SELF COLONCOLON | DESCENDANTORSELF COLONCOLON | FOLLOWINGSIBLING COLONCOLON | FOLLOWING COLONCOLON
/*[79]*/ abbrevForwardStep   ::= AT? nodeTest
/*[80]*/ reverseStep         ::= reverseAxis nodeTest | abbrevReverseStep
/*[81]*/ reverseAxis         ::= PARENT COLONCOLON | ANCESTOR COLONCOLON | PRECEDINGSIBLING COLONCOLON | PRECEDING COLONCOLON | ANCESTORORSELF COLONCOLON
/*[82]*/ abbrevReverseStep   ::= DOTDOT
/*[83]*/ nodeTest            ::= kindTest | nameTest
/*[84]*/ nameTest            ::= qname | wildCard
/*[85]*/ wildCard            ::= STAR | STAR COLON NCNAME | NCNAME COLON STAR
/*[86]*/ filterExpr          ::= primaryExpr predicateList
/*[87]*/ predicateList       ::= predicate*
/*[88]*/ predicate           ::= LBRACKET expr RBRACKET
/*[89]*/ primaryExpr         ::= varRef | literal | parenthesizedExpr | contextItemExpr | functionCall | orderedExpr | unorderedExpr | constructor
/*[90]*/ literal             ::= numericliteral | stringliteral
/*[91]*/ numericliteral      ::= integerLiteral | decimalLiteral
/*[92]*/ varRef              ::= VAR
/*[93]*/ varName             ::= qname
/*[94]*/ parenthesizedExpr   ::= LPAR expr? RPAR
/*[95]*/ contextItemExpr     ::= DOT
/*[96]*/ orderedExpr         ::= ORDERED LCURLY     expr RCURLY    
/*[97]*/ unorderedExpr       ::= UNORDERED LCURLY     expr RCURLY    
/*[98]*/ functionCall        ::= qname LPAR (exprSingle (COMMA exprSingle)*)? RPAR
/*[99]*/ constructor         ::= directConstructor | computedConstructor
/*[100]*/ directConstructor   ::= dirElemConstructor
/*[101]*/ dirElemConstructor  ::= LESSTHAN qname dirAttributeList (ENDTAG| (GREATERTHAN dirElemContent* ENDELM qname WHITESPACE? GREATERTHAN))
/*[102]*/ dirAttributeList    ::= (WHITESPACE     dirAttribute?)*
/*[103]*/ dirAttribute        ::= qname WHITESPACE? EQUALS WHITESPACE? dirAttributeValue
/*[104]*/ dirAttributeValue   ::= enclosedExpr | QSTRING
/*[105]*/ dirElemContent      ::= directConstructor | commonContent | WHITESPACE | NCNAMEELM | cDataSection
/*[106]*/ commonContent       ::= (enclosedExpr_) | | LCURLY LCURLY | RCURLY RCURLY
/*[107]*/ cDataSection        ::= CDATASTART CDATAELMEND
/*[108]*/ computedConstructor ::= compDocConstructor | compElemConstructor | compAttrConstructor | compTextConstructor | compCommentConstructor | compPIConstructor
/*[109]*/ compDocConstructor  ::= DOCUMENT enclosedExpr
/*[110]*/ compElemConstructor ::= ELEMENT ( qname | enclosedExpr_) LCURLY contentExpr? RCURLY
/*[111]*/ contentExpr         ::= expr
/*[112]*/ compAttrConstructor ::= ATTRIBUTE (qname | enclosedExpr) LCURLY expr? RCURLY
/*[113]*/ compTextConstructor ::= TEXT enclosedExpr_
/*[114]*/ compCommentConstructor ::= COMMENT enclosedExpr
/*[115]*/ compPIConstructor   ::= PROCESSINGINSTRUCTION ( NCNAME | enclosedExpr) LCURLY expr? RCURLY
/*[116]*/ singleType          ::= atomicType QUESTIONMARK?
/*[117]*/ typeDeclaration     ::= AS     sequenceType
/*[118]*/ sequenceType        ::= EMPTYSEQUENCE LPAR RPAR | itemType occurrenceIndicator?
/*[119]*/ occurrenceIndicator ::= QUESTIONMARK
/*[120]*/ itemType            ::= ITEM LPAR RPAR | atomicType | kindTest
/*[121]*/ atomicType          ::= qname
/*[122]*/ kindTest            ::= documentTest | elementTest | attributeTest | schemaElementTest | schemaAttributeTest | piTest | commentTest | textTest | anyKindTest
/*[123]*/ anyKindTest         ::= NODE LPAR RPAR
/*[124]*/ documentTest        ::= DOCUMENTNODE LPAR (elementTest | schemaElementTest)? RPAR
/*[125]*/ textTest            ::= TEXT LPAR RPAR
/*[126]*/ commentTest         ::= COMMENT LPAR RPAR
/*[127]*/ piTest              ::= PROCESSINGINSTRUCTION LPAR (NCNAME | stringliteral)? RPAR
/*[128]*/ attributeTest       ::= ATTRIBUTE LPAR (attributeNameOrWildcard (COMMA typeName)?)? RPAR
/*[129]*/ attributeNameOrWildcard ::= attributeName | STAR
/*[130]*/ schemaAttributeTest ::= SCHEMAATTRIBUTE LPAR attributeDeclaration RPAR
/*[131]*/ attributeDeclaration ::= attributeName
/*[132]*/ elementTest         ::= ELEMENT LPAR (elementNameOrWildcard (COMMA typeName QUESTIONMARK?)?)? RPAR
/*[133]*/ elementNameOrWildcard ::= elementName | STAR
/*[134]*/ schemaElementTest   ::= SCHEMAELEMENT LPAR elementDeclaration RPAR
/*[135]*/ elementDeclaration  ::= elementName
/*[136]*/ attributeName       ::= qname
/*[137]*/ elementName         ::= qname
/*[138]*/ typeName            ::= qname
/*[139]*/ uriliteral          ::= stringliteral
/*[140]*/ integerLiteral      ::= INTEGER
/*[141]*/ decimalLiteral      ::= DECIMAL
/*[142]*/ stringliteral       ::= QSTRING
/* SPARQL Non terminals */
/*[1]*/ baseDecl            ::= BASE IRIREF
/*[2]*/ prefixDecl          ::= PREFIX PNAME_NS IRIREF
/*[3]*/ subSelect           ::= selectClause sWhereClause solutionmodifier valuesClause
/*[4]*/ selectClause        ::= SELECT^ (DISTINCT|REDUCED)? sparqlVarOrFunction+ | SELECT^ (DISTINCT|REDUCED)? STAR
/*[5]*/ constructQuery      ::= CONSTRUCT constructTemplate datasetClause* sWhereClause solutionmodifier | CONSTRUCT WHERE LCURLY triplesTemplate  RCURLY solutionmodifier 
/*[6]*/ datasetClause       ::= FROM^ (defaultGraphClause | namedGraphClause )
/*[7]*/ defaultGraphClause  ::= sourceSelector
/*[8]*/ namedGraphClause    ::= NAMED sourceSelector
/*[9]*/ sourceSelector      ::= IRIREF | VAR
/*[10]*/ sWhereClause        ::= WHERE groupGraphPattern
/*[11]*/ solutionmodifier    ::= groupBy? having? orderclause? limitoffsetclauses?
/*[12]*/ groupBy             ::= GROUP BY groupByCondition+
/*[13]*/ groupByCondition    ::= builtInCall | sFunctionCall | LPAR expression (AS VAR)? RPAR | VAR
/*[14]*/ having              ::= HAVING havingCondition+
/*[15]*/ havingCondition     ::= constraint
/*[16]*/ orderclause         ::= ORDER BY orderCondition+
/*[17]*/ orderCondition      ::= (ASC | DESC) brackettedExpression | constraint | VAR
/*[18]*/ limitoffsetclauses  ::= limitclause offsetclause? | offsetclause limitclause?
/*[19]*/ limitclause         ::= LIMIT^ INTEGER
/*[20]*/ offsetclause        ::= OFFSET^ INTEGER
/*[21]*/ valuesClause        ::= (VALUES^ dataBlock)?
/*[22]*/ triplesTemplate     ::= triplesSameSubject ( DOT     triplesTemplate? )?
/*[23]*/ groupGraphPattern   ::= LCURLY     (subSelect|groupGraphPatternSub) RCURLY    
/*[24]*/ groupGraphPatternSub ::= triplesBlock? ((graphPatternNotTriples | filter) DOT    ? triplesBlock?)*
/*[25]*/ triplesBlock        ::= triplesSameSubjectPath (DOT     triplesBlock?)?
/*[26]*/ graphPatternNotTriples ::= optionalGraphPattern | groupOrUnionGraphPattern | graphGraphPattern | minusGraphPattern | serviceGraphPattern | bind | inlineData
/*[27]*/ optionalGraphPattern ::= OPTIONAL^ groupGraphPattern
/*[28]*/ graphGraphPattern   ::= GRAPH^ varOrIRIref groupGraphPattern
/*[29]*/ serviceGraphPattern ::= SERVICE^ SILENT? varOrIRIref groupGraphPattern
/*[30]*/ bind                ::= BIND^ LPAR expression AS VAR RPAR
/*[31]*/ inlineData          ::= VALUES^ dataBlock
/*[32]*/ dataBlock           ::= inlineDataOneVar | inlineDataFull
/*[33]*/ inlineDataOneVar    ::= VAR LCURLY dataBlockValue* RCURLY
/*[34]*/ inlineDataFull      ::= (nil | LPAR VAR+ RPAR) LCURLY (LPAR dataBlockValue+ RPAR | nil)* RCURLY
/*[35]*/ dataBlockValue      ::= sparqlPrefixedName | IRIREF | rdfLiteral | numericliteral | booleanLiteral | UNDEF
/*[36]*/ minusGraphPattern   ::= MINUS^ groupGraphPattern
/*[37]*/ groupOrUnionGraphPattern ::= groupGraphPattern ((UNION groupGraphPattern)+)? 
/*[38]*/ filter              ::= FILTER^ constraint
/*[39]*/ constraint          ::= brackettedExpression | builtInCall | sFunctionCall
/*[40]*/ sFunctionCall       ::= iRIref arglist
/*[41]*/ arglist             ::= LPAR     (expression (COMMA     expression)*)? RPAR    
/*[42]*/ expressionList      ::= nil | LPAR expression (COMMA expression)* RPAR
/*[43]*/ constructTemplate   ::= LCURLY     constructTriples? RCURLY    
/*[44]*/ constructTriples    ::= triplesSameSubject_ (DOT     constructTriples?)? | enclosedExpr (DOT     constructTriples)?
/*[45]*/ triplesSameSubject  ::= subject propertyListNotEmpty | triplesNode propertyListNotEmpty?
/*[46]*/ triplesSameSubject_ ::= subject_ propertyListNotEmpty_ | triplesNode_ propertyListNotEmpty_? 
/*[47]*/ propertyListNotEmpty ::= verb objectList (SEMICOLON (verb objectList)? )*
/*[48]*/ propertyListNotEmpty_ ::= verb_ objectList_ (SEMICOLON (verb_ objectList_)?)*
/*[49]*/ verb                ::= varOrIRIref | A
/*[50]*/ verb_               ::= varOrIRIref_ | A
/*[51]*/ objectList          ::= object (COMMA object)*
/*[52]*/ objectList_         ::= object_ (COMMA object_)*
/*[53]*/ object              ::= resource | blank | rdfLiteral | sNumericLiteral | triplesNode | literalConstruct
/*[54]*/ object_             ::= graphNode_ quad? 
/*[55]*/ quad                ::= iri | literal_
/*[56]*/ literal_            ::= literalConstruct | rdfLiteral
/*[57]*/ triplesSameSubjectPath ::= subject propertyListPathNotEmpty | triplesNodePath propertyListPathNotEmpty?
/*[58]*/ propertyListPathNotEmpty ::= vp objectListPath propertyListPathNotEmptySub*
/*[59]*/ propertyListPathNotEmptySub ::= SEMICOLON (vp objectList)?
/*[60]*/ vp                  ::= (verbPath | verbSimple)
/*[61]*/ verbPath            ::= path
/*[62]*/ verbSimple          ::= VAR
/*[63]*/ objectListPath      ::= objectPath (COMMA objectPath)*
/*[64]*/ objectPath          ::= graphNodePath
/*[65]*/ path                ::= pathAlternative
/*[66]*/ pathAlternative     ::= pathSequence (UNIONSYMBOL pathSequence)*
/*[67]*/ pathSequence        ::= pathEltOrInverse (SLASH pathEltOrInverse)*
/*[68]*/ pathElt             ::= pathPrimary | (pathPrimary pathMod)
/*[69]*/ pathEltOrInverse    ::= pathElt | CARET pathElt
/*[70]*/ pathMod             ::= QUESTIONMARK | STAR | PLUS
/*[71]*/ pathPrimary         ::= iRIref | A | NOT pathNegatedPropertySet | LPAR path RPAR
/*[72]*/ pathNegatedPropertySet ::= pathOneInPropertySet | LPAR (pathOneInPropertySet (UNIONSYMBOL pathOneInPropertySet)*)? RPAR
/*[73]*/ pathOneInPropertySet ::= iRIref | A | CARET (iRIref | A)
/*[74]*/ triplesNode         ::= collection | blankNodePropertyList
/*[75]*/ triplesNode_        ::= collection_ | blankNodePropertyList_
/*[76]*/ blankNodePropertyList ::= LBRACKET propertyListNotEmpty RBRACKET
/*[77]*/ blankNodePropertyList_ ::= LBRACKET propertyListNotEmpty_ RBRACKET
/*[78]*/ triplesNodePath     ::= collectionPath | blanckNodePropertyListPath
/*[79]*/ blanckNodePropertyListPath ::= LBRACKET propertyListPathNotEmpty RBRACKET
/*[80]*/ collection          ::= LPAR graphNode+ RPAR
/*[81]*/ collection_         ::= LPAR graphNode_+ RPAR
/*[82]*/ collectionPath      ::= LPAR graphNodePath+ RPAR
/*[83]*/ graphNode           ::= varOrTerm | triplesNode
/*[84]*/ graphNode_          ::= varOrTerm_ | triplesNode_
/*[85]*/ graphNodePath       ::= VAR | graphTerm | triplesNodePath
/*[86]*/ varOrTerm           ::= VAR | graphTerm
/*[87]*/ varOrTerm_          ::= VAR | iriConstruct | literalConstruct | graphTerm_
/*[88]*/ literalConstruct    ::= enclosedExpr (AT enclosedExpr | CARET CARET iri)? | INTEGER ( AT enclosedExpr | CARET CARET iriConstruct) | QSTRING (AT enclosedExpr | CARET CARET iriConstruct)
/*[89]*/ varOrIRIref         ::= VAR | iRIref
/*[90]*/ varOrIRIref_        ::= VAR | iRIref | iriConstruct
/*[91]*/ iriConstruct        ::= LESSTHANLCURLY expr RCURLYGREATERTHAN | enclosedExpr ( COLON enclosedExpr | OLON? qname ) | qname COLON enclosedExpr
/*[92]*/ graphTerm           ::= iRIref | rdfLiteral | sNumericLiteral | booleanLiteral | blankNode | nil
/*[93]*/ graphTerm_          ::= rdfLiteral | sNumericLiteral | booleanLiteral | blankNode | blankConstruct
/*[94]*/ blankConstruct      ::= BNODE_CONSTRUCT enclosedExpr
/*[95]*/ expression          ::= conditionalOrExpression
/*[96]*/ conditionalOrExpression ::= conditionalAndExpression (ORSYMBOL^ conditionalAndExpression)*
/*[97]*/ conditionalAndExpression ::= valueLogical (ANDSYMBOL^ valueLogical)*
/*[98]*/ valueLogical        ::= relationalExpression
/*[99]*/ relationalExpression ::= numericExpression (((EQUALS | HAFENEQUALS | LESSTHAN | GREATERTHAN | LESSTHANEQUALS | GREATERTHANEQUALS) numericExpression) | ((IN | NOTKW IN) expressionList))?
/*[100]*/ numericExpression   ::= additiveExpression
/*[101]*/ additiveExpression  ::= multiplicativeExpression ( PLUS^ multiplicativeExpression | MINUS^ multiplicativeExpression)*
/*[102]*/ multiplicativeExpression ::= unaryExpression (STAR^ unaryExpression | SLASH^ unaryExpression )*
/*[103]*/ unaryExpression     ::= NOT primaryExpression | (PLUS primaryExpression) | (MINUS primaryExpression) | primaryExpression
/*[104]*/ primaryExpression   ::= brackettedExpression | builtInCall | iRIrefOrFunction | rdfLiteral | sNumericLiteral | booleanLiteral | VAR | BLANK_NODE_LABEL  | LBRACKET RBRACKET 
/*[105]*/ brackettedExpression ::= LPAR expression RPAR
/*[106]*/ builtInCall         ::= STR LPAR expression RPAR | LANG LPAR expression RPAR | LANGMATCHES LPAR expression COMMA expression RPAR | DATATYPE LPAR expression RPAR | BOUND LPAR VAR RPAR | ISIRI LPAR expression RPAR | ISURI LPAR expression RPAR | ISBLANK LPAR expression RPAR | ISLITERAL LPAR expression RPAR | regexExpression | IRI LPAR expression RPAR | URI LPAR expression RPAR | BNODE (LPAR expression RPAR | nil) | RAND nil | ABS LPAR expression RPAR | CEIL LPAR expression RPAR | FLOOR LPAR expression RPAR | ROUND LPAR expression RPAR | CONCAT expressionList | substringExpression | STRLEN LPAR expression RPAR | strReplaceExpression | UCASE LPAR expression RPAR | LCASE LPAR expression RPAR | ENCODE_FOR_URI LPAR expression RPAR | CONTAINS LPAR expression COMMA expression RPAR | STRSTARTS LPAR expression COMMA expression RPAR | STRENDS LPAR expression COMMA expression RPAR | STRBEFORE LPAR expression COMMA expression RPAR | STRAFTER LPAR expression COMMA expression RPAR | YEAR LPAR expression RPAR | MONTH LPAR expression RPAR | DAY LPAR expression RPAR | HOURS LPAR expression RPAR | MINUTES LPAR expression RPAR | SECONDS LPAR expression RPAR | TIMEZONE LPAR expression RPAR | TZ LPAR expression RPAR | NOW nil | UID nil | STRUUID nil | MD5 LPAR expression RPAR | SHA1 LPAR expression RPAR | SHA256 LPAR expression RPAR | SHA384 LPAR expression RPAR | SHA512 LPAR expression RPAR | COALESCE expressionList | IF LPAR expression COMMA expression COMMA expression RPAR | STRLANG LPAR expression COMMA expression RPAR | STRDT LPAR expression COMMA expression RPAR | SAME_TERM LPAR expression COMMA expression RPAR | ISNUMERIC LPAR expression RPAR | aggregate | existsFunc | notExistsFunc
/*[107]*/ regexExpression     ::= REGEX LPAR expression COMMA expression (COMMA  expression)? RPAR
/*[108]*/ substringExpression ::= SUBSTR LPAR expression COMMA expression (COMMA expression)? RPAR
/*[109]*/ strReplaceExpression ::= REPLACE LPAR expression COMMA expression COMMA expression (COMMA expression)? RPAR
/*[110]*/ existsFunc          ::= EXISTS groupGraphPattern
/*[111]*/ notExistsFunc       ::= NOTKW^ EXISTS groupGraphPattern
/*[112]*/ aggregate           ::= COUNT LPAR DISTINCT? (STAR|expression) RPAR | SUM LPAR DISTINCT? expression RPAR | MIN LPAR DISTINCT? expression RPAR | MAX LPAR DISTINCT? expression RPAR | AVG LPAR DISTINCT? expression RPAR | SAMPLE LPAR DISTINCT? expression RPAR | GROUP_CONCAT LPAR DISTINCT? expression (SEMICOLON SEPARATOR EQUALS string)? RPAR
/*[113]*/ iRIrefOrFunction    ::= iRIref arglist?
/*[114]*/ rdfLiteral          ::= QSTRING ( AT NCNAME | CARET CARET ( IRIREF |  PNAME_LN) )?
/*[115]*/ sNumericLiteral     ::= (PLUS|MINUS)? INTEGER | (PLUS|MINUS)? DECIMAL | (PLUS|MINUS)? DOUBLET
/*[116]*/ booleanLiteral      ::= TRUE | FALSE
/*[117]*/ string              ::= QSTRING
/*[118]*/ iRIref              ::= IRIREF | prefixedName
/*[119]*/ prefixedName        ::= PNAME_LN | PNAME_NS
/*[120]*/ blankNode           ::= blank
/*[121]*/ blank               ::= bnode | LBRACKET RBRACKET 
/*[122]*/ nil                 ::= LPAR RPAR
/* Unclassified/XSPARQL */
/*[1]*/ subject_            ::= resource | iriConstruct | blank | blankConstruct | enclosedExpr
/*[2]*/ subject             ::= resource | blank
/*[3]*/ iri                 ::= PNAME_LN | IRIREF | iriConstruct
/*[4]*/ resource            ::= sparqlPrefixedName | VAR | IRIREF
/*[5]*/ rdfPredicate        ::= resource
/*[6]*/ bnode               ::= BLANK_NODE_LABEL
/*[7]*/ sparqlPrefixedName  ::= PNAME_LN | PNAME_NS
/*[8]*/ qname               ::= prefixedName | unprefixedName | COUNT | MAX | MIN | AVG | SUM | SAMPLE | NOTKW | EXISTS
/*[9]*/ keyword             ::= ITEM | TO | FROM | COMMENT | ROW | NODE | A
/*[10]*/ unprefixedName      ::= localPart
/*[11]*/ localPart           ::= NCNAME | keyword
/* SQL Non terminals */
/*[1]*/ sqlForClause ::= FOR DISTINCT? (STAR | sqlVarOrFunctionList | ROW VAR) relationClause sqlWhereClause?
/*[2]*/ sqlVarOrFunctionList ::= sqlVarOrFunction[false] (COMMA     sqlVarOrFunction[true])*
/*[3]*/ sqlVarOrFunction ::= qname | LPAR functionCall AS VAR RPAR | VAR
/*[4]*/ relationClause ::= FROM rdbSourceSelector (COMMA rdbSourceSelector)* | FROM qname LPAR rdbSourceSelectorFunctionParams? RPAR
/*[5]*/ rdbSourceSelectorFunctionParams ::= rdbSourceSelector (COMMA rdbSourceSelector)* | QSTRING
/*[6]*/ rdbSourceSelector ::= relationSchemaName relationAlias? 
/*[7]*/ relationSchemaName ::= (relationAlias DOT)? relationAlias
/*[8]*/ relationAlias ::= qname | VAR 
/*[9]*/ sqlWhereClause ::= WHERE^ sqlWhereSpecList
/*[10]*/ sqlWhereSpecList ::= sqlAttrSpecList (sqlBooleanOp sqlAttrSpecList)*
/*[11]*/ sqlAttrSpecList ::= sqlAttrSpec generalComp sqlAttrSpec | LPAR sqlWhereSpecList RPAR
/*[12]*/ sqlBooleanOp ::= AND | OR
/*[13]*/ sqlAttrSpec ::= qname | VAR | literal | enclosedExpr
