/* This format can be fed to http://bottlecaps.de/rr/ui */

/* xQuery Non terminals */
/*[1]*/ module              ::= versionDecl? (libraryModule | mainModule)
/*[2]*/ versionDecl         ::= XQUERY VERSION stringliteral (ENCODING stringliteral)? separator
/*[3]*/ mainModule          ::= prolog queryBody
/*[4]*/ libraryModule       ::= moduleDecl prolog
/*[5]*/ moduleDecl          ::= MODULE NAMESPACE NCNAME EQUALS uriliteral separator
/*[6]*/ prolog              ::= baseDecl? (((defaultNamespaceDecl | namespaceDecl | setter | importa) separator    ) | prefixDecl)* ((varDecl | functionDecl | optionDecl) separator    )*
/*[7]*/ setter              ::= boundarySpaceDecl | defaultCollationDecl | baseURIDecl | constructionDecl | orderingModeDecl | emptyOrderDecl | copyNamespacesDecl
/*[8]*/ importa             ::= schemaImport | moduleImport
/*[9]*/ separator           ::= SEMICOLON
/*[10]*/ namespaceDecl       ::= DECLARE NAMESPACE NCNAME EQUALS QSTRING
/*[11]*/ boundarySpaceDecl   ::= DECLARE BOUNDARYSPACE (PRESERVE | STRIP)
/*[12]*/ defaultNamespaceDecl::= DECLARE DEFAULT (ELEMENT | FUNCTION) NAMESPACE QSTRING
/*[13]*/ optionDecl          ::= DECLARE OPTION qname stringliteral
/*[14]*/ orderingModeDecl    ::= DECLARE ORDERING (ORDERED | UNORDERED)
/*[15]*/ emptyOrderDecl      ::= DECLARE DEFAULT ORDER EMPTY (GREATEST | LEAST )
/*[16]*/ copyNamespacesDecl  ::= DECLARE     COPYNAMESPACES^ preserveMode COMMA     inheritMode
/*[17]*/ preserveMode        ::= PRESERVE | NOPRESERVE
/*[18]*/ inheritMode         ::= INHERIT | NOINHERIT
/*[19]*/ defaultCollationDecl::= DECLARE DEFAULT COLLATION uriliteral
/*[20]*/ baseURIDecl         ::= DECLARE BASEURI QSTRING
/*[21]*/ schemaImport        ::= IMPORT SCHEMA schemaPrefix? uriliteral (AT uriliteral (COMMA uriliteral)*)?
/*[22]*/ schemaPrefix        ::= NAMESPACE     NCNAME EQUALS     | DEFAULT ELEMENT     NAMESPACE    
/*[23]*/ moduleImport        ::= IMPORT MODULE (NAMESPACE NCNAME EQUALS)? uriliteral (AT uriliteral (COMMA uriliteral)*)?
/*[24]*/ varDecl             ::= DECLARE VARIABLE VAR typeDeclaration? ( ASSIGN exprSingle | EXTERNAL )
/*[25]*/ constructionDecl    ::= DECLARE CONSTRUCTION (STRIP | PRESERVE)
/*[26]*/ functionDecl        ::= DECLARE FUNCTION qname LPAR paramList? RPAR (AS sequenceType)? (enclosedExpr | EXTERNAL)
/*[27]*/ paramList           ::= param (COMMA     param)*
/*[28]*/ param               ::= VAR typeDeclaration?
/*[29]*/ enclosedExpr        ::= LCURLY     expr RCURLY    
/*[30]*/ queryBody           ::= exprSingle (COMMA exprSingle)*
/*[31]*/ expr                ::= exprSingle (COMMA     exprSingle)*
/*[32]*/ exprSingle          ::= flworExpr | quantifiedExpr | typeSwitchExpr | constructQuery | orExpr | ifExpr
/*[33]*/ flworExpr           ::= (CONSTRUCT constructTemplate) | (RETURN exprSingle) | forletClause
/*[34]*/ forletClause        ::= FOR     (sparqlForClause | sqlForClause | (xqueryForClause whereClause? orderByClause?)) | letClause whereClause? orderByClause?
/*[35]*/ sparqlForClause     ::= DISTINCT? sparqlVarOrFunction+ datasetClause* endpointClause? sWhereClause solutionmodifier valuesClause | DISTINCT? STAR datasetClause* endpointClause? sWhereClause solutionmodifier valuesClause
/*[36]*/ distinctOrReduced   ::= DISTINCT | REDUCED
/*[37]*/ endpointClause      ::= ENDPOINT sourceSelector
/*[38]*/ sparqlVarOrFunction ::= VAR | LPAR expression AS VAR RPAR
/*[39]*/ xqueryForClause     ::= singleForClause (COMMA     singleForClause)*
/*[40]*/ singleForClause     ::= VAR typeDeclaration? positionalVar? IN exprSingle
/*[41]*/ positionalVar       ::= AT     VAR
/*[42]*/ letClause           ::= LET     singleLetClause (COMMA     singleLetClause)*
/*[43]*/ singleLetClause     ::= VAR typeDeclaration? ASSIGN exprSingle
/*[44]*/ whereClause         ::= WHERE exprSingle
/*[45]*/ orderByClause       ::= ORDER BY orderSpecList | STABLE ORDER BY orderSpecList
/*[46]*/ orderSpecList       ::= orderSpec (COMMA orderSpec)*
/*[47]*/ orderSpec           ::= exprSingle orderModifier
/*[48]*/ orderModifier       ::= (ASCENDING | DESCENDING)? (EMPTY (GREATEST | LEAST))? (COLLATION uriliteral)?
/*[49]*/ quantifiedExpr      ::= (SOME | EVERY) VAR typeDeclaration? IN exprSingle (COMMA VAR typeDeclaration? IN exprSingle)* SATISFIES exprSingle
/*[50]*/ typeSwitchExpr      ::= TYPESWITCH^ LPAR     expr RPAR     caseClause+ DEFAULT     VAR? RETURN     exprSingle
/*[51]*/ caseClause          ::= CASE (VAR AS)? sequenceType RETURN exprSingle
/*[52]*/ ifExpr              ::= IF^ LPAR     expr RPAR     THEN     exprSingle ELSE     exprSingle
/*[53]*/ orExpr              ::= andExpr (OR^ andExpr)*
/*[54]*/ andExpr             ::= comparisonExpr (AND comparisonExpr)*
/*[55]*/ comparisonExpr      ::= ((valueComp^ | generalComp^ | nodeComp^) rangeExpr)?
/*[56]*/ rangeExpr           ::= additiveExpr (TO additiveExpr)?
/*[57]*/ additiveExpr        ::= multiplicativeExpr ((PLUS | MINUS) multiplicativeExpr)*
/*[58]*/ multiplicativeExpr  ::= unionExpr ((STAR | DIV | IDIV | MOD) unionExpr)*
/*[59]*/ unionExpr           ::= intersectExceptExpr ((UNION | UNIONSYMBOL) intersectExceptExpr)*
/*[60]*/ intersectExceptExpr ::= instanceOfExpr ((INTERSECT | EXCEPT) instanceOfExpr)*
/*[61]*/ instanceOfExpr      ::= treatExpr (INSTANCE OF sequenceType)?
/*[62]*/ treatExpr           ::= castableExpr (TREAT AS sequenceType)?
/*[63]*/ castableExpr        ::= castExpr (CASTABLE AS singleType)?
/*[64]*/ castExpr            ::= unaryExpr (CAST AS singleType)?
/*[65]*/ unaryExpr           ::= (MINUS | PLUS)* valueExpr
/*[66]*/ valueExpr           ::= pathExpr | validateExpr | extensionExpr
/*[67]*/ generalComp         ::= EQUALS | LESSTHAN | GREATERTHAN | LESSTHANEQUALS | GREATERTHANEQUALS | HAFENEQUALS
/*[68]*/ valueComp           ::= ( EQ | NE | LT | LE | GT | GE )
/*[69]*/ nodeComp            ::= ( LESSTHANLESSTHAN | GREATERTHANGREATERTHAN | IS )
/*[70]*/ validateExpr        ::= VALIDATE validationMode? LCURLY     expr RCURLY    
/*[71]*/ validationMode      ::= (LAX | STRICT)
/*[72]*/ extensionExpr       ::= LCURLY     expr? RCURLY    
/*[73]*/ pathExpr            ::= (SLASH SLASH) | (SLASH relativePathExpr) | SLASH | relativePathExpr
/*[74]*/ relativePathExpr    ::= stepExpr (SLASH SLASH? stepExpr)*
/*[75]*/ stepExpr            ::= filterExpr | axisStep
/*[76]*/ axisStep            ::= (reverseStep | forwardStep) predicateList
/*[77]*/ forwardStep         ::= forwardAxis nodeTest | abbrevForwardStep
/*[78]*/ forwardAxis         ::= CHILD COLONCOLON | DESCENDANT COLONCOLON | ATTRIBUTE COLONCOLON | SELF COLONCOLON | DESCENDANTORSELF COLONCOLON | FOLLOWINGSIBLING COLONCOLON | FOLLOWING COLONCOLON
/*[79]*/ abbrevForwardStep   ::= AT? nodeTest
/*[80]*/ reverseStep         ::= reverseAxis nodeTest | abbrevReverseStep
/*[81]*/ reverseAxis         ::= PARENT COLONCOLON | ANCESTOR COLONCOLON | PRECEDINGSIBLING COLONCOLON | PRECEDING COLONCOLON | ANCESTORORSELF COLONCOLON
/*[82]*/ abbrevReverseStep   ::= DOTDOT
/*[83]*/ nodeTest            ::= kindTest | nameTest
/*[84]*/ nameTest            ::= qname | wildCard
/*[85]*/ wildCard            ::= STAR | STAR COLON NCNAME | NCNAME COLON STAR
/*[86]*/ filterExpr          ::= primaryExpr predicateList
/*[87]*/ predicateList       ::= predicate*
/*[88]*/ predicate           ::= LBRACKET expr RBRACKET
/*[89]*/ primaryExpr         ::= varRef | literal | parenthesizedExpr | contextItemExpr | functionCall | orderedExpr | unorderedExpr | constructor
/*[90]*/ literal             ::= numericliteral | stringliteral
/*[91]*/ numericliteral      ::= integerLiteral | decimalLiteral
/*[92]*/ varRef              ::= VAR
/*[93]*/ varName             ::= qname
/*[94]*/ parenthesizedExpr   ::= LPAR expr? RPAR
/*[95]*/ contextItemExpr     ::= DOT
/*[96]*/ orderedExpr         ::= ORDERED LCURLY     expr RCURLY    
/*[97]*/ unorderedExpr       ::= UNORDERED LCURLY     expr RCURLY    
/*[98]*/ functionCall        ::= qname LPAR (exprSingle (COMMA exprSingle)*)? RPAR
/*[99]*/ constructor         ::= directConstructor | computedConstructor
/*[100]*/ directConstructor   ::= dirElemConstructor
/*[101]*/ dirElemConstructor  ::= LESSTHAN qname dirAttributeList (ENDTAG| (GREATERTHAN dirElemContent* ENDELM qname WHITESPACE? GREATERTHAN))
/*[102]*/ dirAttributeList    ::= (WHITESPACE     dirAttribute?)*
/*[103]*/ dirAttribute        ::= qname WHITESPACE? EQUALS WHITESPACE? dirAttributeValue
/*[104]*/ dirAttributeValue   ::= enclosedExpr | QSTRING
/*[105]*/ dirElemContent      ::= directConstructor | commonContent | WHITESPACE | NCNAMEELM | cDataSection
/*[106]*/ commonContent       ::= (enclosedExpr_) | | LCURLY LCURLY | RCURLY RCURLY
/*[107]*/ cDataSection        ::= CDATASTART CDATAELMEND
/*[108]*/ computedConstructor ::= compDocConstructor | compElemConstructor | compAttrConstructor | compTextConstructor | compCommentConstructor | compPIConstructor
/*[109]*/ compDocConstructor  ::= DOCUMENT enclosedExpr
/*[110]*/ compElemConstructor ::= ELEMENT ( qname | enclosedExpr_) LCURLY contentExpr? RCURLY
/*[111]*/ contentExpr         ::= expr
/*[112]*/ compAttrConstructor ::= ATTRIBUTE (qname | enclosedExpr) LCURLY expr? RCURLY
/*[113]*/ compTextConstructor ::= TEXT enclosedExpr_
/*[114]*/ compCommentConstructor ::= COMMENT enclosedExpr
/*[115]*/ compPIConstructor   ::= PROCESSINGINSTRUCTION ( NCNAME | enclosedExpr) LCURLY expr? RCURLY
/*[116]*/ singleType          ::= atomicType QUESTIONMARK?
/*[117]*/ typeDeclaration     ::= AS     sequenceType
/*[118]*/ sequenceType        ::= EMPTYSEQUENCE LPAR RPAR | itemType occurrenceIndicator?
/*[119]*/ occurrenceIndicator ::= QUESTIONMARK
/*[120]*/ itemType            ::= ITEM LPAR RPAR | atomicType | kindTest
/*[121]*/ atomicType          ::= qname
/*[122]*/ kindTest            ::= documentTest | elementTest | attributeTest | schemaElementTest | schemaAttributeTest | piTest | commentTest | textTest | anyKindTest
/*[123]*/ anyKindTest         ::= NODE LPAR RPAR
/*[124]*/ documentTest        ::= DOCUMENTNODE LPAR (elementTest | schemaElementTest)? RPAR
/*[125]*/ textTest            ::= TEXT LPAR RPAR
/*[126]*/ commentTest         ::= COMMENT LPAR RPAR
/*[127]*/ piTest              ::= PROCESSINGINSTRUCTION LPAR (NCNAME | stringliteral)? RPAR
/*[128]*/ attributeTest       ::= ATTRIBUTE LPAR (attributeNameOrWildcard (COMMA typeName)?)? RPAR
/*[129]*/ attributeNameOrWildcard ::= attributeName | STAR
/*[130]*/ schemaAttributeTest ::= SCHEMAATTRIBUTE LPAR attributeDeclaration RPAR
/*[131]*/ attributeDeclaration ::= attributeName
/*[132]*/ elementTest         ::= ELEMENT LPAR (elementNameOrWildcard (COMMA typeName QUESTIONMARK?)?)? RPAR
/*[133]*/ elementNameOrWildcard ::= elementName | STAR
/*[134]*/ schemaElementTest   ::= SCHEMAELEMENT LPAR elementDeclaration RPAR
/*[135]*/ elementDeclaration  ::= elementName
/*[136]*/ attributeName       ::= qname
/*[137]*/ elementName         ::= qname
/*[138]*/ typeName            ::= qname
/*[139]*/ uriliteral          ::= stringliteral
/*[140]*/ integerLiteral      ::= INTEGER
/*[141]*/ decimalLiteral      ::= DECIMAL
/*[142]*/ stringliteral       ::= QSTRING
/* SPARQL Non terminals */
/*[1]*/ baseDecl            ::= BASE IRIREF
/*[2]*/ prefixDecl          ::= PREFIX PNAME_NS IRIREF
/*[3]*/ subSelect           ::= selectClause sWhereClause solutionmodifier valuesClause
/*[4]*/ selectClause        ::= SELECT^ (DISTINCT|REDUCED)? sparqlVarOrFunction+ | SELECT^ (DISTINCT|REDUCED)? STAR
/*[5]*/ constructQuery      ::= CONSTRUCT constructTemplate datasetClause* sWhereClause solutionmodifier | CONSTRUCT WHERE LCURLY triplesTemplate  RCURLY solutionmodifier 
/*[6]*/ datasetClause       ::= FROM^ (defaultGraphClause | namedGraphClause )
/*[7]*/ defaultGraphClause  ::= sourceSelector
/*[8]*/ namedGraphClause    ::= NAMED sourceSelector
/*[9]*/ sourceSelector      ::= IRIREF | VAR
/*[10]*/ sWhereClause        ::= WHERE groupGraphPattern
/*[11]*/ solutionmodifier    ::= groupBy? having? orderclause? limitoffsetclauses?
/*[12]*/ groupBy             ::= GROUP BY groupByCondition+
/*[13]*/ groupByCondition    ::= builtInCall | sFunctionCall | LPAR expression (AS VAR)? RPAR | VAR
/*[14]*/ having              ::= HAVING havingCondition+
/*[15]*/ havingCondition     ::= constraint
/*[16]*/ orderclause         ::= ORDER BY orderCondition+
/*[17]*/ orderCondition      ::= (ASC | DESC) brackettedExpression | constraint | VAR
/*[18]*/ limitoffsetclauses  ::= limitclause offsetclause? | offsetclause limitclause?
/*[19]*/ limitclause         ::= LIMIT^ INTEGER
/*[20]*/ offsetclause        ::= OFFSET^ INTEGER
/*[21]*/ valuesClause        ::= (VALUES^ dataBlock)?
/*[22]*/ triplesTemplate     ::= triplesSameSubject ( DOT     triplesTemplate? )?
/*[23]*/ groupGraphPattern   ::= LCURLY     (subSelect|groupGraphPatternSub) RCURLY    
/*[24]*/ groupGraphPatternSub ::= triplesBlock? ((graphPatternNotTriples | filter) DOT    ? triplesBlock?)*
/*[25]*/ triplesBlock        ::= triplesSameSubjectPath (DOT     triplesBlock?)?
/*[26]*/ graphPatternNotTriples ::= optionalGraphPattern | groupOrUnionGraphPattern | graphGraphPattern | minusGraphPattern | serviceGraphPattern | bind | inlineData
/*[27]*/ optionalGraphPattern ::= OPTIONAL^ groupGraphPattern
/*[28]*/ graphGraphPattern   ::= GRAPH^ varOrIRIref groupGraphPattern
/*[29]*/ serviceGraphPattern ::= SERVICE^ SILENT? varOrIRIref groupGraphPattern
/*[30]*/ bind                ::= BIND^ LPAR expression AS VAR RPAR
/*[31]*/ inlineData          ::= VALUES^ dataBlock
/*[32]*/ dataBlock           ::= inlineDataOneVar | inlineDataFull
/*[33]*/ inlineDataOneVar    ::= VAR LCURLY dataBlockValue* RCURLY
/*[34]*/ inlineDataFull      ::= (nil | LPAR VAR+ RPAR) LCURLY (LPAR dataBlockValue+ RPAR | nil)* RCURLY
/*[35]*/ dataBlockValue      ::= sparqlPrefixedName | IRIREF | rdfLiteral | numericliteral | booleanLiteral | UNDEF
/*[36]*/ minusGraphPattern   ::= MINUS^ groupGraphPattern
/*[37]*/ groupOrUnionGraphPattern ::= groupGraphPattern ((UNION groupGraphPattern)+)? 
/*[38]*/ filter              ::= FILTER^ constraint
/*[39]*/ constraint          ::= brackettedExpression | builtInCall | sFunctionCall
/*[40]*/ sFunctionCall       ::= iRIref arglist
/*[41]*/ arglist             ::= LPAR     (expression (COMMA     expression)*)? RPAR    
/*[42]*/ expressionList      ::= nil | LPAR expression (COMMA expression)* RPAR
/*[43]*/ constructTemplate   ::= LCURLY     constructTriples? RCURLY    
/*[44]*/ constructTriples    ::= triplesSameSubject_ (DOT     constructTriples?)? | enclosedExpr (DOT     constructTriples)?
/*[45]*/ triplesSameSubject  ::= subject propertyListNotEmpty | triplesNode propertyListNotEmpty?
/*[46]*/ triplesSameSubject_ ::= subject_ propertyListNotEmpty_ | triplesNode_ propertyListNotEmpty_? 
/*[47]*/ propertyListNotEmpty ::= verb objectList (SEMICOLON (verb objectList)? )*
/*[48]*/ propertyListNotEmpty_ ::= verb_ objectList_ (SEMICOLON (verb_ objectList_)?)*
/*[49]*/ verb                ::= varOrIRIref | A
/*[50]*/ verb_               ::= varOrIRIref_ | A
/*[51]*/ objectList          ::= object (COMMA object)*
/*[52]*/ objectList_         ::= object_ (COMMA object_)*
/*[53]*/ object              ::= resource | blank | rdfLiteral | sNumericLiteral | triplesNode | literalConstruct
/*[54]*/ object_             ::= graphNode_ quad? 
/*[55]*/ quad                ::= iri | literal_
/*[56]*/ literal_            ::= literalConstruct | rdfLiteral
/*[57]*/ triplesSameSubjectPath ::= subject propertyListPathNotEmpty | triplesNodePath propertyListPathNotEmpty?
/*[58]*/ propertyListPathNotEmpty ::= vp objectListPath propertyListPathNotEmptySub*
/*[59]*/ propertyListPathNotEmptySub ::= SEMICOLON (vp objectList)?
/*[60]*/ vp                  ::= (verbPath | verbSimple)
/*[61]*/ verbPath            ::= path
/*[62]*/ verbSimple          ::= VAR
/*[63]*/ objectListPath      ::= objectPath (COMMA objectPath)*
/*[64]*/ objectPath          ::= graphNodePath
/*[65]*/ path                ::= pathAlternative
/*[66]*/ pathAlternative     ::= pathSequence (UNIONSYMBOL pathSequence)*
/*[67]*/ pathSequence        ::= pathEltOrInverse (SLASH pathEltOrInverse)*
/*[68]*/ pathElt             ::= pathPrimary | (pathPrimary pathMod)
/*[69]*/ pathEltOrInverse    ::= pathElt | CARET pathElt
/*[70]*/ pathMod             ::= QUESTIONMARK | STAR | PLUS
/*[71]*/ pathPrimary         ::= iRIref | A | NOT pathNegatedPropertySet | LPAR path RPAR
/*[72]*/ pathNegatedPropertySet ::= pathOneInPropertySet | LPAR (pathOneInPropertySet (UNIONSYMBOL pathOneInPropertySet)*)? RPAR
/*[73]*/ pathOneInPropertySet ::= iRIref | A | CARET (iRIref | A)
/*[74]*/ triplesNode         ::= collection | blankNodePropertyList
/*[75]*/ triplesNode_        ::= collection_ | blankNodePropertyList_
/*[76]*/ blankNodePropertyList ::= LBRACKET propertyListNotEmpty RBRACKET
/*[77]*/ blankNodePropertyList_ ::= LBRACKET propertyListNotEmpty_ RBRACKET
/*[78]*/ triplesNodePath     ::= collectionPath | blanckNodePropertyListPath
/*[79]*/ blanckNodePropertyListPath ::= LBRACKET propertyListPathNotEmpty RBRACKET
/*[80]*/ collection          ::= LPAR graphNode+ RPAR
/*[81]*/ collection_         ::= LPAR graphNode_+ RPAR
/*[82]*/ collectionPath      ::= LPAR graphNodePath+ RPAR
/*[83]*/ graphNode           ::= varOrTerm | triplesNode
/*[84]*/ graphNode_          ::= varOrTerm_ | triplesNode_
/*[85]*/ graphNodePath       ::= VAR | graphTerm | triplesNodePath
/*[86]*/ varOrTerm           ::= VAR | graphTerm
/*[87]*/ varOrTerm_          ::= VAR | iriConstruct | literalConstruct | graphTerm_
/*[88]*/ literalConstruct    ::= enclosedExpr (AT enclosedExpr | CARET CARET iri)? | INTEGER ( AT enclosedExpr | CARET CARET iriConstruct) | QSTRING (AT enclosedExpr | CARET CARET iriConstruct)
/*[89]*/ varOrIRIref         ::= VAR | iRIref
/*[90]*/ varOrIRIref_        ::= VAR | iRIref | iriConstruct
/*[91]*/ iriConstruct        ::= LESSTHANLCURLY expr RCURLYGREATERTHAN | enclosedExpr ( COLON enclosedExpr | OLON? qname ) | qname COLON enclosedExpr
/*[92]*/ graphTerm           ::= iRIref | rdfLiteral | sNumericLiteral | booleanLiteral | blankNode | nil
/*[93]*/ graphTerm_          ::= rdfLiteral | sNumericLiteral | booleanLiteral | blankNode | blankConstruct
/*[94]*/ blankConstruct      ::= BNODE_CONSTRUCT enclosedExpr
/*[95]*/ expression          ::= conditionalOrExpression
/*[96]*/ conditionalOrExpression ::= conditionalAndExpression (ORSYMBOL^ conditionalAndExpression)*
/*[97]*/ conditionalAndExpression ::= valueLogical (ANDSYMBOL^ valueLogical)*
/*[98]*/ valueLogical        ::= relationalExpression
/*[99]*/ relationalExpression ::= numericExpression (((EQUALS | HAFENEQUALS | LESSTHAN | GREATERTHAN | LESSTHANEQUALS | GREATERTHANEQUALS) numericExpression) | ((IN | NOTKW IN) expressionList))?
/*[100]*/ numericExpression   ::= additiveExpression
/*[101]*/ additiveExpression  ::= multiplicativeExpression ( PLUS^ multiplicativeExpression | MINUS^ multiplicativeExpression)*
/*[102]*/ multiplicativeExpression ::= unaryExpression (STAR^ unaryExpression | SLASH^ unaryExpression )*
/*[103]*/ unaryExpression     ::= NOT primaryExpression | (PLUS primaryExpression) | (MINUS primaryExpression) | primaryExpression
/*[104]*/ primaryExpression   ::= brackettedExpression | builtInCall | iRIrefOrFunction | rdfLiteral | sNumericLiteral | booleanLiteral | VAR | BLANK_NODE_LABEL  | LBRACKET RBRACKET 
/*[105]*/ brackettedExpression ::= LPAR expression RPAR
/*[106]*/ builtInCall         ::= STR LPAR expression RPAR | LANG LPAR expression RPAR | LANGMATCHES LPAR expression COMMA expression RPAR | DATATYPE LPAR expression RPAR | BOUND LPAR VAR RPAR | ISIRI LPAR expression RPAR | ISURI LPAR expression RPAR | ISBLANK LPAR expression RPAR | ISLITERAL LPAR expression RPAR | regexExpression | IRI LPAR expression RPAR | URI LPAR expression RPAR | BNODE (LPAR expression RPAR | nil) | RAND nil | ABS LPAR expression RPAR | CEIL LPAR expression RPAR | FLOOR LPAR expression RPAR | ROUND LPAR expression RPAR | CONCAT expressionList | substringExpression | STRLEN LPAR expression RPAR | strReplaceExpression | UCASE LPAR expression RPAR | LCASE LPAR expression RPAR | ENCODE_FOR_URI LPAR expression RPAR | CONTAINS LPAR expression COMMA expression RPAR | STRSTARTS LPAR expression COMMA expression RPAR | STRENDS LPAR expression COMMA expression RPAR | STRBEFORE LPAR expression COMMA expression RPAR | STRAFTER LPAR expression COMMA expression RPAR | YEAR LPAR expression RPAR | MONTH LPAR expression RPAR | DAY LPAR expression RPAR | HOURS LPAR expression RPAR | MINUTES LPAR expression RPAR | SECONDS LPAR expression RPAR | TIMEZONE LPAR expression RPAR | TZ LPAR expression RPAR | NOW nil | UID nil | STRUUID nil | MD5 LPAR expression RPAR | SHA1 LPAR expression RPAR | SHA256 LPAR expression RPAR | SHA384 LPAR expression RPAR | SHA512 LPAR expression RPAR | COALESCE expressionList | IF LPAR expression COMMA expression COMMA expression RPAR | STRLANG LPAR expression COMMA expression RPAR | STRDT LPAR expression COMMA expression RPAR | SAME_TERM LPAR expression COMMA expression RPAR | ISNUMERIC LPAR expression RPAR | aggregate | existsFunc | notExistsFunc
/*[107]*/ regexExpression     ::= REGEX LPAR expression COMMA expression (COMMA  expression)? RPAR
/*[108]*/ substringExpression ::= SUBSTR LPAR expression COMMA expression (COMMA expression)? RPAR
/*[109]*/ strReplaceExpression ::= REPLACE LPAR expression COMMA expression COMMA expression (COMMA expression)? RPAR
/*[110]*/ existsFunc          ::= EXISTS groupGraphPattern
/*[111]*/ notExistsFunc       ::= NOTKW^ EXISTS groupGraphPattern
/*[112]*/ aggregate           ::= COUNT LPAR DISTINCT? (STAR|expression) RPAR | SUM LPAR DISTINCT? expression RPAR | MIN LPAR DISTINCT? expression RPAR | MAX LPAR DISTINCT? expression RPAR | AVG LPAR DISTINCT? expression RPAR | SAMPLE LPAR DISTINCT? expression RPAR | GROUP_CONCAT LPAR DISTINCT? expression (SEMICOLON SEPARATOR EQUALS string)? RPAR
/*[113]*/ iRIrefOrFunction    ::= iRIref arglist?
/*[114]*/ rdfLiteral          ::= QSTRING ( AT NCNAME | CARET CARET ( IRIREF |  PNAME_LN) )?
/*[115]*/ sNumericLiteral     ::= (PLUS|MINUS)? INTEGER | (PLUS|MINUS)? DECIMAL | (PLUS|MINUS)? DOUBLET
/*[116]*/ booleanLiteral      ::= TRUE | FALSE
/*[117]*/ string              ::= QSTRING
/*[118]*/ iRIref              ::= IRIREF | prefixedName
/*[119]*/ prefixedName        ::= PNAME_LN | PNAME_NS
/*[120]*/ blankNode           ::= blank
/*[121]*/ blank               ::= bnode | LBRACKET RBRACKET 
/*[122]*/ nil                 ::= LPAR RPAR
/* Unclassified/XSPARQL */
/*[1]*/ subject_            ::= resource | iriConstruct | blank | blankConstruct | enclosedExpr
/*[2]*/ subject             ::= resource | blank
/*[3]*/ iri                 ::= PNAME_LN | IRIREF | iriConstruct
/*[4]*/ resource            ::= sparqlPrefixedName | VAR | IRIREF
/*[5]*/ rdfPredicate        ::= resource
/*[6]*/ bnode               ::= BLANK_NODE_LABEL
/*[7]*/ sparqlPrefixedName  ::= PNAME_LN | PNAME_NS
/*[8]*/ qname               ::= prefixedName | unprefixedName | COUNT | MAX | MIN | AVG | SUM | SAMPLE | NOTKW | EXISTS
/*[9]*/ keyword             ::= ITEM | TO | FROM | COMMENT | ROW | NODE | A
/*[10]*/ unprefixedName      ::= localPart
/*[11]*/ localPart           ::= NCNAME | keyword
/* SQL Non terminals */
/*[1]*/ sqlForClause ::= FOR DISTINCT? (STAR | sqlVarOrFunctionList | ROW VAR) relationClause sqlWhereClause?
/*[2]*/ sqlVarOrFunctionList ::= sqlVarOrFunction[false] (COMMA     sqlVarOrFunction[true])*
/*[3]*/ sqlVarOrFunction ::= qname | LPAR functionCall AS VAR RPAR | VAR
/*[4]*/ relationClause ::= FROM rdbSourceSelector (COMMA rdbSourceSelector)* | FROM qname LPAR rdbSourceSelectorFunctionParams? RPAR
/*[5]*/ rdbSourceSelectorFunctionParams ::= rdbSourceSelector (COMMA rdbSourceSelector)* | QSTRING
/*[6]*/ rdbSourceSelector ::= relationSchemaName relationAlias? 
/*[7]*/ relationSchemaName ::= (relationAlias DOT)? relationAlias
/*[8]*/ relationAlias ::= qname | VAR 
/*[9]*/ sqlWhereClause ::= WHERE^ sqlWhereSpecList
/*[10]*/ sqlWhereSpecList ::= sqlAttrSpecList (sqlBooleanOp sqlAttrSpecList)*
/*[11]*/ sqlAttrSpecList ::= sqlAttrSpec generalComp sqlAttrSpec | LPAR sqlWhereSpecList RPAR
/*[12]*/ sqlBooleanOp ::= AND | OR
/*[13]*/ sqlAttrSpec ::= qname | VAR | literal | enclosedExpr
/* Terminals */ 
/*[1]*/ LineTerminator          ::= "\r|\n|\r\n"
/*[2]*/ WhiteSpace              ::= LineTerminator | [\t\f ]
/*[3]*/ PN_CHARS_BASE           ::= [A-Za-z]
/*[4]*/ PN_CHARS_U              ::= PN_CHARS_BASE | _
/*[5]*/ PN_CHARS                ::= PN_CHARS_U | "-" | [0-9]
/*[6]*/ PN_PREFIX               ::= PN_CHARS_BASE ((PN_CHARS|"\.")* PN_CHARS)?
/*[7]*/ PN_LOCAL                ::= ( PN_CHARS_U | [0-9] ) ((PN_CHARS|"\.")* PN_CHARS)?
/*[8]*/ iri                     ::= '< ([^<>\"\{\}\|\^`\\])* >'
/*[9]*/ var                     ::= [\$][a-zA-Z]([a-zA-Z0-9\_\-\.]*[a-zA-Z0-9\_\-]+)?
/*[10]*/ digit                   ::= [0-9]
/*[11]*/ LESSTHAN                ::= "\<"
/*[12]*/ BIND                    ::= "bind"
/*[13]*/ SLASH                   ::= "\/"
/*[14]*/ SLASHSLASH              ::= "//\/\/"
/*[15]*/ LBRACKET                ::= "\["
/*[16]*/ RBRACKET                ::= "\]"
/*[17]*/ LPAR                    ::= "\("
/*[18]*/ RPAR                    ::= "\)"
/*[19]*/ SEMICOLON               ::= "\;"
/*[20]*/ QSTRING                 ::= '\"(\"\"|[^\"])*\"' | "\'(\'\'|[^\'])*\'"
/*[21]*/ INTEGER                 ::= digit+ 
/*[22]*/ DECIMAL                 ::= "/*""."digit+ | /*[0-9]+"."[0-9]*
/*[23]*/ EXPONENT                ::= "/*"("e"|"E")[0-9]+
/*[24]*/ DOUBLET                 ::= /*[0-9]+\.[0-9]*[eE][\+\-]?[0-9]+ | /*"."[0-9]+[eE][\+\-]?[0-9]+ | /*[0-9]+("e"|"E")(\+|\-)?[0-9]+
/*[25]*/ DOT                     ::= "\."
/*[26]*/ AT                      ::= "@"
/*[27]*/ CARET                   ::= "\^"
/*[28]*/ CARETCARET              ::= "//\^\^"
/*[29]*/ ASSIGN                  ::= "\:\::="
/*[30]*/ COLON                   ::= "\:"
/*[31]*/ COLONCOLON              ::= "\:\:"
/*[32]*/ COMMA                   ::= "\,"
/*[33]*/ EQUALS                  ::= "\::="
/*[34]*/ STAR                    ::= "\*"
/*[35]*/ DOTDOT                  ::= "\.\."
/*[36]*/ PLUS                    ::= "\+"
/*[37]*/ MINUS                   ::= "\-"
/*[38]*/ UNIONSYMBOL             ::= "\|"
/*[39]*/ ANDSYMBOL               ::= "&&"
/*[40]*/ ORSYMBOL                ::= "\|\|"
/*[41]*/ QUESTIONMARK            ::= "\?"
/*[42]*/ LESSTHANLESSTHAN        ::= "\<\<"
/*[43]*/ GREATERTHANEQUALS       ::= "\>\::="
/*[44]*/ LESSTHANEQUALS          ::= "\<\::="
/*[45]*/ HAFENEQUALS             ::= "\t\::="
/*[46]*/ NOT                     ::= "\"    
/*[47]*/ A                       ::= "a"                      
/*[48]*/ IS                      ::= "is"                     
/*[49]*/ EQ                      ::= "eq"                     
/*[50]*/ NE                      ::= "ne"                     
/*[51]*/ LT                      ::= "lt"                     
/*[52]*/ GE                      ::= "ge"                     
/*[53]*/ LE                      ::= "le"                     
/*[54]*/ GT                      ::= "gt"                     
/*[55]*/ FOR                     ::= "for"                    
/*[56]*/ ENDPOINT                ::= "endpoint"               
/*[57]*/ FROM                    ::= "from"                   
/*[58]*/ LIMIT                   ::= "limit"                  
/*[59]*/ OFFSET                  ::= "offset"                 
/*[60]*/ DISTINCT                ::= "distinct"               
/*[61]*/ REDUCED                 ::= "reduced"                  
/*[62]*/ GROUP                   ::= "group"                  
/*[63]*/ HAVING                  ::= "having"                 
/*[64]*/ LET                     ::= "let"                    
/*[65]*/ ORDER                   ::= "order"                  
/*[66]*/ BY                      ::= "by"                     
/*[67]*/ AT                      ::= "at"                     
/*[68]*/ IN                      ::= "in"                     
/*[69]*/ AS                      ::= "as"                     
/*[70]*/ DESCENDING              ::= "descending"             
/*[71]*/ ASCENDING               ::= "ascending"              
/*[72]*/ STABLE                  ::= "stable"                 
/*[73]*/ ROW                     ::= "row"                    
/*[74]*/ IF                      ::= "if"                     
/*[75]*/ THEN                    ::= "then"                   
/*[76]*/ ELSE                    ::= "else"                   
/*[77]*/ RETURN                  ::= "return"                 
/*[78]*/ CONSTRUCT               ::= "construct"              
/*[79]*/ WHERE                   ::= "where"WhiteSpace*"\{" | "where"            
/*[80]*/ GREATEST                ::= "greatest"               
/*[81]*/ LEAST                   ::= "least"                  
/*[82]*/ COLLATION               ::= "collation"              
/*[83]*/ ORDERED                 ::= "ordered"                
/*[84]*/ UNORDERED               ::= "unordered"              
/*[85]*/ DECLARE                 ::= "declare"                
/*[86]*/ NAMESPACE               ::= "namespace"              
/*[87]*/ DEFAULT                 ::= "default"                
/*[88]*/ ELEMENT                 ::= "element"                
/*[89]*/ OPTION                  ::= "option"                 
/*[90]*/ FUNCTION                ::= "function"               
/*[91]*/ BASEURI                 ::= "base-uri"               
/*[92]*/ PREFIX                  ::= "prefix"                 
/*[93]*/ BASE                    ::= "base"                   
/*[94]*/ AND                     ::= "and"                    
/*[95]*/ OR                      ::= "or"                     
/*[96]*/ TO                      ::= "to"                     
/*[97]*/ DIV                     ::= "div"                    
/*[98]*/ IDIV                    ::= "idiv"                   
/*[99]*/ MOD                     ::= "mod"                    
/*[100]*/ UNION                   ::= "union"                  
/*[101]*/ INTERSECT               ::= "intersect"              
/*[102]*/ EXCEPT                  ::= "except"                 
/*[103]*/ INSTANCE                ::= "instance"               
/*[104]*/ TREAT                   ::= "treat"                  
/*[105]*/ CASTABLE                ::= "castable"               
/*[106]*/ CAST                    ::= "cast"                   
/*[107]*/ OF                      ::= "of"                     
/*[108]*/ EMPTYSEQUENCE           ::= "empty-sequence"         
/*[109]*/ ITEM                    ::= "item"                   
/*[110]*/ NODE                    ::= "node"                   
/*[111]*/ DOCUMENTNODE            ::= "document-node"          
/*[112]*/ COMMENT                 ::= "comment"                
/*[113]*/ PROCESSINGINSTRUCTION   ::= "processing-instruction" 
/*[114]*/ SCHEMAATTRIBUTE         ::= "schema-attribute"       
/*[115]*/ SCHEMAELEMENT           ::= "schema-element"         
/*[116]*/ DOCUMENT                ::= "document"               
/*[117]*/ OPTIONAL                ::= "optional"               
/*[118]*/ FILTER                  ::= "filter"                 
/*[119]*/ STR                     ::= "str"                    
/*[120]*/ LANG                    ::= "lang"                   
/*[121]*/ LANGMATCHES             ::= "langmatches"            
/*[122]*/ DATATYPE                ::= "datatype"               
/*[123]*/ BOUND                   ::= "bound"                  
/*[124]*/ ISIRI                   ::= "isiri"                  
/*[125]*/ ISURI                   ::= "isuri"                  
/*[126]*/ ISBLANK                 ::= "isblank"                
/*[127]*/ ISLITERAL               ::= "isliteral"              
/*[128]*/ REGEX                   ::= "regex"                  
/*[129]*/ TRUE                    ::= "true"                   
/*[130]*/ FALSE                   ::= "false"                  
/*[131]*/ GRAPH                   ::= "graph"                  
/*[132]*/ COUNT                   ::= "count"                  
/*[133]*/ SUM                     ::= "sum"                       
/*[134]*/ MAX                     ::= "max"                       
/*[135]*/ MIN                     ::= "min"                       
/*[136]*/ AVG                     ::= "avg"                       
/*[137]*/ SAMPLE                  ::= "sample"                    
/*[138]*/ GROUP_CONCAT            ::= "group_concat"              
/*[139]*/ SEPARATOR               ::= "separator"              
/*[140]*/ SELECT                  ::= "select"              
/*[141]*/ EXISTS                  ::= "exists"              
/*[142]*/ NOTKW                   ::= "not"        
/*[143]*/ MINUS                   ::= "minus"        
/*[144]*/ SERVICE                 ::= "service"    
/*[145]*/ SILENT                  ::= "silent"    
/*[146]*/ VALUES                  ::= "values"    
/*[147]*/ UNDEF                   ::= "undef"        
/*[148]*/ SUBSTR                  ::= "substr"    
/*[149]*/ REPLACE                 ::= "replace"    
/*[150]*/ IRI                     ::= "iri"        
/*[151]*/ URI                     ::= "uri"        
/*[152]*/ BNODE                   ::= "bnode"        
/*[153]*/ ABS                     ::= "abs"        
/*[154]*/ CEIL                    ::= "ceil"        
/*[155]*/ FLOOR                   ::= "floor"        
/*[156]*/ ROUND                   ::= "round"        
/*[157]*/ CONCAT                  ::= "concat"
/*[158]*/ STRLEN                  ::= "strlen"
/*[159]*/ UCASE                   ::= "ucase"        
/*[160]*/ LCASE                   ::= "lcase"        
/*[161]*/ ENCODE_FOR_URI          ::= "encode_for_uri"
/*[162]*/ CONTAINS                ::= "contains"            
/*[163]*/ STRSTARTS               ::= "strstarts"             
/*[164]*/ STRENDS                 ::= "strends"    
/*[165]*/ STRBEFORE               ::= "strbefore"             
/*[166]*/ STRAFTER                ::= "strafter"             
/*[167]*/ ISNUMERIC               ::= "isnumeric"             
/*[168]*/ YEAR                    ::= "year"        
/*[169]*/ MONTH                   ::= "month"        
/*[170]*/ DAY                     ::= "day"        
/*[171]*/ HOURS                   ::= "hours"        
/*[172]*/ MINUTES                 ::= "minutes"    
/*[173]*/ SECONDS                 ::= "seconds"    
/*[174]*/ TIMEZONE                ::= "timezone"             
/*[175]*/ TZ                      ::= "tz"        
/*[176]*/ NOW                     ::= "now"        
/*[177]*/ UID                     ::= "uuid"        
/*[178]*/ STRUUID                 ::= "struuid"    
/*[179]*/ MD5                     ::= "md5"        
/*[180]*/ SHA1                    ::= "sha1"        
/*[181]*/ SHA256                  ::= "sha256"    
/*[182]*/ SHA384                  ::= "sha384"    
/*[183]*/ SHA512                  ::= "sha512"    
/*[184]*/ COALESCE                ::= "coalesce"             
/*[185]*/ IF                      ::= "if"     
/*[186]*/ STRLANG                 ::= "strlang"    
/*[187]*/ STRDT                   ::= "strdt"     
/*[188]*/ SAME_TERM               ::= "sameterm"             
/*[189]*/ CHILD                   ::= "child"             
/*[190]*/ DESCENDANT              ::= "descendant"        
/*[191]*/ ATTRIBUTE               ::= "attribute"         
/*[192]*/ SELF                    ::= "self"              
/*[193]*/ DESCENDANTORSELF        ::= "descendant-or-self"
/*[194]*/ FOLLOWINGSIBLING        ::= "following-sibling" 
/*[195]*/ FOLLOWING               ::= "following"         
/*[196]*/ PARENT                  ::= "parent"            
/*[197]*/ ANCESTOR                ::= "ancestor"          
/*[198]*/ PRECEDINGSIBLING        ::= "preceding-sibling" 
/*[199]*/ PRECEDING               ::= "preceding"         
/*[200]*/ ANCESTORORSELF          ::= "ancestor-or-self"  
/*[201]*/ BOUNDARYSPACE           ::= "boundary-space"    
/*[202]*/ STRIP                   ::= "strip"             
/*[203]*/ VARIABLE                ::= "variable"          
/*[204]*/ IMPORT                  ::= "import"            
/*[205]*/ EXTERNAL                ::= "external"          
/*[206]*/ NOPRESERVE              ::= "no-preserve"       
/*[207]*/ PRESERVE                ::= "preserve"          
/*[208]*/ CONSTRUCTION            ::= "construction"      
/*[209]*/ MODULE                  ::= "module"            
/*[210]*/ INHERIT                 ::= "inherit"           
/*[211]*/ NOINHERIT               ::= "no-inherit"        
/*[212]*/ SCHEMA                  ::= "schema"            
/*[213]*/ IMPORT                  ::= "import"            
/*[214]*/ EMPTY                   ::= "empty"             
/*[215]*/ EXTERNAL                ::= "external"          
/*[216]*/ ORDERING                ::= "ordering"          
/*[217]*/ COPYNAMESPACES          ::= "copy-namespaces"   
/*[218]*/ XQUERY                  ::= "xquery"            
/*[219]*/ VERSION                 ::= "version"           
/*[220]*/ ENCODING                ::= "encoding"          
/*[221]*/ LAX                     ::= "lax"               
/*[222]*/ CASE                    ::= "case"              
/*[223]*/ EVERY                   ::= "every"             
/*[224]*/ TYPESWITCH              ::= "typeswitch"        
/*[225]*/ SATISFIES               ::= "satisfies"         
/*[226]*/ VALIDATE                ::= "validate"          
/*[227]*/ SOME                    ::= "some"              
/*[228]*/ STRICT                  ::= "strict"            
/*[229]*/ ASC                     ::= "asc" 
/*[230]*/ DESC                    ::= "desc"
/*[231]*/ BLANK_NODE_LABEL        ::= "_:"PN_PREFIX
/*[232]*/ BNODE_CONSTRUCT         ::= "_:"(PN_PREFIX)?"/\{"
/*[233]*/ PNAME_LN                ::= PN_PREFIX?":"PN_LOCAL
/*[234]*/ PNAME_NS                ::= PN_PREFIX?":/"[^\:\{]
/*[235]*/ NCNAME                  ::= PN_PREFIX
/*[236]*/ VAR                     ::= var
/*[237]*/ XQueryComment           ::= "(:[^(\(\:)(\:\))]*|[:\(\)]:)"
/*[238]*/ ENDELM                  ::= "<\/" 
/*[239]*/ GREATERTHAN             ::= "\>"
/*[240]*/ RCURLY                  ::= "\}"
/*[241]*/ LCURLY                  ::= "\{"
/*[242]*/ RCURLYGREATERTHAN       ::= "\}>"
/*[243]*/ LESSTHANLCURLY          ::= "<{"
/*[244]*/ ENDTAG                  ::= "\/\>" 
/*[245]*/ CDATASTART              ::= "<    [CDATA["
/*[246]*/ NCNAMEELM               ::= [^\{\}\<(\(\:)]+
/*[247]*/ CDATAELMEND             ::= (.|[\^]|"\n"|"\t"|"\r")*"\]\]>"
/*[248]*/ WHITESPACE              ::= WhiteSpace+
/*[249]*/ IRIREF                  ::= iri
/*[250]*/ NAMED                   ::= "named"
