XSPARQL issues list:

* IMPLEMENTATION:
=================

*) repair lifitng example in XSPARQL

*) Should we allow:
   FROM variable or even FROM expressionSingle 
   or only 
   FROM iriREF, as we do now

*) What about the empty strings appended in concats? e.g.

fn:concat( "@", $NS_1, ".", "" ), 
                          ^^^^???

let $aux1 := fn:concat("http://localhost:2020/sparql?query=", 
   fn:encode-for-uri( fn:concat( $NS_1, " select $s $p $x from 
   <http://www.polleres.net/xsparql/data/alice.ttl> where 
   { $s $p $x . } ", "" ))) 
                   ^^^^^??
  
*) change saxon to xqilla in the web interface and let's hope that 
   improves speed...
   Problem for xqilla on the server to access remote files.

*) Problem in output for simple. sparql

@prefix : <http://www.example.org>.
b0 :p [b0_:a1].
b0 :p [b0_:a2]. 

should be:

_:b0 :p [_:b0 _:a1].
^^       ^^  ^
_:b0 :p [_:b0 _:a2]. 
^^       ^^  ^

*) Are the      
     xsparql:rdfterm(),  <-- maybe we should add this... 
     xsparql:bound(), 
     xsparql:isIRI(), 
     xsparql:isBlank(), 
     xsparql:isLiteral() 
     xsparql:lang() and
     xsparql:datatype() we should be fine.

dowe also need the following? 
    xsparql:str2rdfResource(xsd:string) (encode-for-uri and enclose into '<' '>' ),
    xsparql:str2rdfLiteral(xsd:string) (escaping quotes inside the string and putting the result into double quotes), xsparql:
    xsparql:str2typedRdfLiteral(xsd:string,xsd:string) 
 
 functions already defined?

*) Add testcases for all the above!

* TR:
=====

*) check whether we properly define what reusing a variable $X bound in a graph pattern within
   an XQuery part... Actually, it should be fine now... with just taking $X as data($X_Node) 
   and defining access-functions 
     xsparql:rdfterm(),  <-- maybe we should add this... 
     xsparql:bound(), 
     xsparql:isIRI(), 
     xsparql:isBlank(), 
     xsparql:isLiteral() 
     xsparql:lang() and
     xsparql:datatype() we should be fine.
 
   As for what is currently in the report, we need to add exmples for this, we need to add the RDFTerm function
   and we have to clarify, whether we need the xsparql namespace?
   
* we have to change the example for vCard (Fig.8)b)) to :

  prefix vc: <http://www.w3.org/vcard-rdf/>
  prefix foaf: <http://xmlns.com/foaf/>
  construct { _:b foaf:name {fn:concat(""",$N," ", $F,""")}.}
  from <http://www.polleres.net/xsparql/data/vCard.rdf>
  where { ?P vc:Given $N. ?P vc:Family $F. ?P vc:Famy $F. }

*)  more detailed proofs here:

"By similar arguments, we can see that SPARQL's \CONSTRUCT queries 
are treated semantically equivalent in XSPARQL and in SPARQL. The idea 
here is that the rwriting rules \CONSTRUCT{s} from 
Section~\ref{sec:constructsem} extract exacxtly the triples from the solution sequence from the body defined as defined in the SPARQL semantics~\cite{sparql}."

*) Complete the rewriting rules at page 13 of the current report!

*) after that and when implementation is ready, contact herman, prud' heumaux, connolly, hawke and ask for possiblity of note submission.


