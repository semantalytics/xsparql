/**
 *
 * Copyright (C) 2011, NUI Galway.
 * All rights reserved.
 *
 * The software in this package is published under the terms of the BSD style license a copy of which has been included
 * with this distribution in the bsb_license.txt file and/or available on NUI Galway Server at
 * http://www.deri.ie/publications/tools/bsd_license.txt
 *
 * Created: 09 February 2011, Reasoning and Querying Unit (URQ), Digital Enterprise Research Institute (DERI) on behalf of
 * NUI Galway.
 */
package org.deri.xsparql;

import org.antlr.runtime.*;

import java.util.Stack;

/**
 * Lexer for XSPARQL generated by JFlex
 *
 * @author Stefan Bischof
 */
%%

/* -----------------Options and Declarations Section----------------- */

/*
   The name of the class JFlex will create will be Lexer.
   Will write the code to the file Lexer.java.
*/
%class XSPARQLLexer

/* Make Lexer public class */
%public

// ANTLR
%implements TokenSource
%type Token

/*
  The current line number can be accessed with the variable yyline
  and the current column number with the variable yycolumn.
*/
%line
%column

/* Use unicode */
%unicode

/* name of the generated symbols interface */
//%cupsym org.deri.xsparql.Symbols

/*
   Will switch to a CUP compatibility mode to interface with a CUP
   generated parser.
*/
//%cup

/* Create main method for Lexer class for testing */
//%cupdebug

/*
  Declarations

  Code between %{ and %}, both of which must be at the beginning of a
  line, will be copied letter to letter into the lexer class source.
  Here you declare member variables and functions that are used inside
  scanner actions.
*/
%{

   /**
    * Stack for Lexer states
    */
   private Stack<Integer> stateStack = new Stack<Integer>();

   /* To create a new java_cup.runtime.Symbol with information about
      the current token, the token will have no value in this
      case. */
/*   private Symbol symbol(int type) {
      Symbol s = new Symbol(type, yyline, yycolumn);

      if(debug) {
         System.out.println("Line " + (yyline+1) + ", Col " + (yycolumn+1) + " in state " + getStateName(yystate()) + ": " + getTokenName(s.sym));
      }

      return s;
   }*/

   /* Also creates a new java_cup.runtime.Symbol with information
      about the current token, but this object has a value. */
/*   private Symbol symbol(int type, Object value) {
      Symbol s = new Symbol(type, yyline, yycolumn, value);

      if(debug) {
         System.out.println("Line " + (yyline+1) + ", Col " + (yycolumn+1) + " in state " + getStateName(yystate()) + ": " + getTokenName(s.sym) + " \"" + yytext() + "\"");
      }

      return s;
   }*/

   /*
    * Push current state to stack and change to state
    *
    * @param state The state to switch to
    */
   private void pushStateAndSwitch(int state) {
      stateStack.push(yystate());
      if(Configuration.debuglexer()) {
         System.out.println("Push state");
      }
      switchState(state);
   }

   /*
    * Pop stack state and switch to that state
    */
   private void popState() {
      int state = stateStack.pop().intValue();
      if(Configuration.debuglexer()) {
         System.out.println("Pop state");
      }
      switchState(state);
   }

   /*
    * Switch to another state without any stack interaction
    */
   public void switchState(int state) {
      if(Configuration.debuglexer()) {
         System.out.println("Switch state " + getStateName(state));
      }
      yybegin(state);
   }

   /*
    * Get the name of a state, like getTokenName
    */
   public static String getStateName(int state) {
      try {
         java.lang.reflect.Field [] classFields = org.deri.xsparql.XSPARQLLexer.class.getFields();
         for (int i = 0; i < classFields.length; i++) {
           if (classFields[i].getInt(null) == state) {
             return classFields[i].getName();
           }
         }
       } catch (Exception e) {
         e.printStackTrace(System.err);
       }

       return "UNKNOWN STATE";
   }

   // implements antlr.TokenSource

   /* (non-Javadoc)
	 * @see org.antlr.runtime.TokenSource#nextToken()
	 */
   public Token nextToken() {
        try {
            return yylex();
        }
        catch (java.io.IOException e) {
            System.err.println("shouldn't happen: " + e.getMessage());
            return Token.EOF_TOKEN;
        }
    }

    /** Turn 1-based to 0-based. */
    public void setLine(int line) {
        this.yyline = line-1;
    }

    public void setColumn(int column) {
        this.yycolumn = column;
    }

    public int getLine() {
        return this.yyline+1;
    }

    public int getColumn() {
        return this.yycolumn;
    }

    private Token symbol(int type, String text) {
        CommonToken token = new CommonToken(type, text);
        token.setLine(getLine());
        token.setCharPositionInLine(getColumn());

        if(Configuration.debuglexer()) {
           System.out.println("Line " + (yyline+1) + ", Col " + (yycolumn+1) + " in state " + getStateName(yystate()) + ": " + XSPARQL.tokenNames[type] + " \"" + text + "\"");
        }
        return token;
    }

    private Token symbol(int type) {
        CommonToken token = new CommonToken(type, yytext());
        token.setLine(getLine());
        token.setCharPositionInLine(getColumn());

        if(Configuration.debuglexer()) {
           System.out.println("Line " + (yyline+1) + ", Col " + (yycolumn+1) + " in state " + getStateName(yystate()) + ": " + XSPARQL.tokenNames[type]);
        }
        return token;
    }

    /* (non-Javadoc)
	 * @see org.antlr.runtime.TokenSource#getSourceName()
	 */
	public String getSourceName() {
	   return null;
 	}

%}


/* -----------------Macro Declarations Section----------------- */

/* inclusive states */
%states xmlStartTag
%states xmlEndTag

/* exclusive states */
%xstates xmlElementContents
%xstates cdata

// state after a "prefix" or "from"
%xstates SPARQL

// state will be entered immediately after a SPARQL where
%xstates SPARQL_PRE_WHERE

// state will be entered after "where {"
%xstates SPARQL_WHERE

// state will be entered immediately after a construct
%xstates SPARQL_PRE_CONSTRUCT

// state will be entered after "construct {"
%xstates SPARQL_CONSTRUCT

%xstates XQueryComment


/*
  Macro Declarations

  These declarations are regular expressions that will be used latter
  in the Lexical Rules Section.
*/

/* A line terminator is a \r (carriage return), \n (line feed), or
   \r\n. */
LineTerminator    = \r|\n|\r\n

/* White space is a line terminator, space, tab, or line feed. */
WhiteSpace        = {LineTerminator} | [ \t\f]


/* http://www.w3.org/TR/rdf-sparql-query/#rPrefixedName */
PN_CHARS_BASE     = [A-Za-z]
PN_CHARS_U        = {PN_CHARS_BASE} | _
PN_CHARS          = {PN_CHARS_U} | - | [0-9]
PN_PREFIX         = {PN_CHARS_BASE} (({PN_CHARS}|\.)* {PN_CHARS})?
PN_LOCAL          = ( {PN_CHARS_U} | [0-9] ) (({PN_CHARS}|\.)* {PN_CHARS})?

iri               = < ([^<>\"\{\}\|\^`\\])* >

var               = [\$][a-zA-Z][a-zA-Z0-9\_\-]*

%%

<YYINITIAL, xmlElementContents, SPARQL_CONSTRUCT, xmlStartTag> 
{

  \<         { pushStateAndSwitch(xmlStartTag);
               return symbol(XSPARQL.LESSTHAN, yytext()); }

}

<SPARQL_WHERE> 
{

  \<         { return symbol(XSPARQL.LESSTHAN, yytext()); }

}

<YYINITIAL, xmlElementContents, SPARQL_WHERE, SPARQL_CONSTRUCT, xmlStartTag> 
{

\/         { return symbol(XSPARQL.SLASH, yytext()); }
//\/\/       { return symbol(XSPARQL.SLASHSLASH, yytext()); }
\[         { return symbol(XSPARQL.LBRACKET, yytext()); }
\]         { return symbol(XSPARQL.RBRACKET, yytext()); }
\(         { return symbol(XSPARQL.LPAR, yytext()); }
\)         { return symbol(XSPARQL.RPAR, yytext()); }
\;         { return symbol(XSPARQL.SEMICOLON, yytext()); }
\"[^\"]*\" { return symbol(XSPARQL.QSTRING, yytext().substring(1, yytext().length()-1)); }
\'[^\']*\' { String ret = yytext().replaceAll("\"", "\"\""); 
             ret = ret.substring(1, ret.length()-1).replaceAll("''", "'"); 
             return symbol(XSPARQL.QSTRING, ret); }
[0-9]+     { return symbol(XSPARQL.INTEGER, yytext()); }
"."[0-9]+  { return symbol(XSPARQL.DECIMAL, yytext()); }
[0-9]+\.[0-9]*  { return symbol(XSPARQL.DECIMAL, yytext()); }
\.         { return symbol(XSPARQL.DOT, yytext()); }
@          { return symbol(XSPARQL.AT , yytext()); }
\^       { return symbol(XSPARQL.CARET, yytext()); }
//\^\^       { return symbol(XSPARQL.CARETCARET, yytext()); }
\:\=       { return symbol(XSPARQL.ASSIGN, yytext()); }
\:         { return symbol(XSPARQL.COLON, yytext()); }
\:\:       { return symbol(XSPARQL.COLONCOLON, yytext()); }
\,         { return symbol(XSPARQL.COMMA, yytext()); }
\=         { return symbol(XSPARQL.EQUALS, yytext()); }
\*         { return symbol(XSPARQL.STAR, yytext()); }
\.\.       { return symbol(XSPARQL.DOTDOT, yytext()); }
\+         { return symbol(XSPARQL.PLUS, yytext()); }
\-         { return symbol(XSPARQL.MINUS, yytext()); }
\|         { return symbol(XSPARQL.UNIONSYMBOL, yytext()); }
&&         { return symbol(XSPARQL.ANDSYMBOL, yytext()); }
\|\|       { return symbol(XSPARQL.ORSYMBOL, yytext()); }
\?         { return symbol(XSPARQL.QUESTIONMARK, yytext()); }
\<\<       { return symbol(XSPARQL.LESSTHANLESSTHAN, yytext()); }
\>\=       { return symbol(XSPARQL.GREATERTHANEQUALS, yytext()); }
\<\=       { return symbol(XSPARQL.LESSTHANEQUALS, yytext()); }
\!\=       { return symbol(XSPARQL.HAFENEQUALS, yytext()); }
\!         { return symbol(XSPARQL.NOT, yytext()); }

}

<YYINITIAL, xmlElementContents, SPARQL_WHERE, SPARQL_CONSTRUCT> 
{

/* keywords */

"a"                      { return symbol(XSPARQL.A, yytext()); }
"is"                     { return symbol(XSPARQL.IS, yytext()); }
"eq"                     { return symbol(XSPARQL.EQ, yytext()); }
"ne"                     { return symbol(XSPARQL.NE, yytext()); }
"lt"                     { return symbol(XSPARQL.LT, yytext()); }
"ge"                     { return symbol(XSPARQL.GE, yytext()); }
"le"                     { return symbol(XSPARQL.LE, yytext()); }
"gt"                     { return symbol(XSPARQL.GT, yytext()); }
"for"                    { return symbol(XSPARQL.FOR, yytext()); }
"from"                   { pushStateAndSwitch(SPARQL);
                           return symbol(XSPARQL.FROM, yytext()); }
"limit"                  { return symbol(XSPARQL.LIMIT, yytext()); }
"offset"                 { return symbol(XSPARQL.OFFSET, yytext()); }
"distinct"               { return symbol(XSPARQL.DISTINCT, yytext()); }
"group"                  { return symbol(XSPARQL.GROUP, yytext()); }
"having"                 { return symbol(XSPARQL.HAVING, yytext()); }
"let"                    { return symbol(XSPARQL.LET, yytext()); }
"order"                  { return symbol(XSPARQL.ORDER, yytext()); }
"by"                     { return symbol(XSPARQL.BY, yytext()); }
"at"                     { return symbol(XSPARQL.AT, yytext()); }
"in"                     { return symbol(XSPARQL.IN, yytext()); }
"as"                     { return symbol(XSPARQL.AS, yytext()); }
"descending"             { return symbol(XSPARQL.DESCENDING, yytext()); }
"ascending"              { return symbol(XSPARQL.ASCENDING, yytext()); }
"stable"                 { return symbol(XSPARQL.STABLE, yytext()); }
"if"                     { return symbol(XSPARQL.IF, yytext()); }
"then"                   { return symbol(XSPARQL.THEN, yytext()); }
"else"                   { return symbol(XSPARQL.ELSE, yytext()); }
"return"                 { return symbol(XSPARQL.RETURN, yytext()); }
"construct"              { pushStateAndSwitch(SPARQL_PRE_CONSTRUCT);
                           return symbol(XSPARQL.CONSTRUCT, yytext()); }
"where"/{WhiteSpace}*\{  { pushStateAndSwitch(SPARQL_PRE_WHERE);
                           return symbol(XSPARQL.WHERE, yytext()); }
"where"                  { return symbol(XSPARQL.WHERE, yytext()); }
"greatest"               { return symbol(XSPARQL.GREATEST, yytext()); }
"least"                  { return symbol(XSPARQL.LEAST, yytext()); }
"collation"              { return symbol(XSPARQL.COLLATION, yytext()); }
"ordered"                { return symbol(XSPARQL.ORDERED, yytext()); }
"unordered"              { return symbol(XSPARQL.UNORDERED, yytext()); }
"declare"                { return symbol(XSPARQL.DECLARE, yytext()); }
"namespace"              { return symbol(XSPARQL.NAMESPACE, yytext()); }
"default"                { return symbol(XSPARQL.DEFAULT, yytext()); }
"element"                { return symbol(XSPARQL.ELEMENT, yytext()); }
"function"               { return symbol(XSPARQL.FUNCTION, yytext()); }
"base-uri"               { return symbol(XSPARQL.BASEURI, yytext()); }
"prefix"                 { pushStateAndSwitch(SPARQL);
                           return symbol(XSPARQL.PREFIX, yytext()); }
"base"                   { return symbol(XSPARQL.BASE, yytext()); }
"and"                    { return symbol(XSPARQL.AND, yytext()); }
"or"                     { return symbol(XSPARQL.OR, yytext()); }
"to"                     { return symbol(XSPARQL.TO, yytext()); }
"div"                    { return symbol(XSPARQL.DIV, yytext()); }
"idiv"                   { return symbol(XSPARQL.IDIV, yytext()); }
"mod"                    { return symbol(XSPARQL.MOD, yytext()); }
"union"                  { return symbol(XSPARQL.UNION, yytext()); }
"intersect"              { return symbol(XSPARQL.INTERSECT, yytext()); }
"except"                 { return symbol(XSPARQL.EXCEPT, yytext()); }
"instance"               { return symbol(XSPARQL.INSTANCE, yytext()); }
"treat"                  { return symbol(XSPARQL.TREAT, yytext()); }
"castable"               { return symbol(XSPARQL.CASTABLE, yytext()); }
"cast"                   { return symbol(XSPARQL.CAST, yytext()); }
"of"                     { return symbol(XSPARQL.OF, yytext()); }
"empty-sequence"         { return symbol(XSPARQL.EMPTYSEQUENCE, yytext()); }
"item"                   { return symbol(XSPARQL.ITEM, yytext()); }
"node"                   { return symbol(XSPARQL.NODE, yytext()); }
"document-node"          { return symbol(XSPARQL.DOCUMENTNODE, yytext()); }
/* "text"                   { return symbol(XSPARQL.TEXT, yytext()); } */
"comment"                { return symbol(XSPARQL.COMMENT, yytext()); }
"processing-instruction" { return symbol(XSPARQL.PROCESSINGINSTRUCTION, yytext()); }
"schema-attribute"       { return symbol(XSPARQL.SCHEMAATTRIBUTE, yytext()); }
"schema-element"         { return symbol(XSPARQL.SCHEMAELEMENT, yytext()); }
"document"               { return symbol(XSPARQL.DOCUMENT, yytext()); }
"optional"               { return symbol(XSPARQL.OPTIONAL, yytext()); }
"filter"                 { return symbol(XSPARQL.FILTER, yytext()); }
"str"                    { return symbol(XSPARQL.STR, yytext()); }
"lang"                   { return symbol(XSPARQL.LANG, yytext()); }
"langmatches"            { return symbol(XSPARQL.LANGMATCHES, yytext()); }
"datatype"               { return symbol(XSPARQL.DATATYPE, yytext()); }
"bound"                  { return symbol(XSPARQL.BOUND, yytext()); }
"isiri"                  { return symbol(XSPARQL.ISIRI, yytext()); }
"isuri"                  { return symbol(XSPARQL.ISURI, yytext()); }
"isblank"                { return symbol(XSPARQL.ISBLANK, yytext()); }
"isliteral"              { return symbol(XSPARQL.ISLITERAL, yytext()); }
"regex"                  { return symbol(XSPARQL.REGEX, yytext()); }
"true"                   { return symbol(XSPARQL.TRUE, yytext()); }
"false"                  { return symbol(XSPARQL.FALSE, yytext()); }
"graph"                  { return symbol(XSPARQL.GRAPH, yytext()); }

}

<YYINITIAL, xmlElementContents> 
{

"child"                  { return symbol(XSPARQL.CHILD, yytext()); }
"descendant"             { return symbol(XSPARQL.DESCENDANT, yytext()); }
"attribute"              { return symbol(XSPARQL.ATTRIBUTE, yytext()); }
"self"                   { return symbol(XSPARQL.SELF, yytext()); }
"descendant-or-self"     { return symbol(XSPARQL.DESCENDANTORSELF, yytext()); }
"following-sibling"      { return symbol(XSPARQL.FOLLOWINGSIBLING, yytext()); }
"following"              { return symbol(XSPARQL.FOLLOWING, yytext()); }
"parent"                 { return symbol(XSPARQL.PARENT, yytext()); }
"ancestor"               { return symbol(XSPARQL.ANCESTOR, yytext()); }
"preceding-sibling"      { return symbol(XSPARQL.PRECEDINGSIBLING, yytext()); }
"preceding"              { return symbol(XSPARQL.PRECEDING, yytext()); }
"ancestor-or-self"       { return symbol(XSPARQL.ANCESTORORSELF, yytext()); }

"boundary-space"         { return symbol(XSPARQL.BOUNDARYSPACE, yytext()); }
"strip"                  { return symbol(XSPARQL.STRIP, yytext()); }
"variable"               { return symbol(XSPARQL.VARIABLE, yytext()); }
"import"                 { return symbol(XSPARQL.IMPORT, yytext()); }
"external"               { return symbol(XSPARQL.EXTERNAL, yytext()); }
"no-preserve"            { return symbol(XSPARQL.NOPRESERVE, yytext()); }
"preserve"               { return symbol(XSPARQL.PRESERVE, yytext()); }
"construction"           { return symbol(XSPARQL.CONSTRUCTION, yytext()); }
"module"                 { return symbol(XSPARQL.MODULE, yytext()); }
"inherit"                { return symbol(XSPARQL.INHERIT, yytext()); }
"no-inherit"             { return symbol(XSPARQL.NOINHERIT, yytext()); }
"schema"                 { return symbol(XSPARQL.SCHEMA, yytext()); }
"import"                 { return symbol(XSPARQL.IMPORT, yytext()); }
"empty"                  { return symbol(XSPARQL.EMPTY, yytext()); }
"external"               { return symbol(XSPARQL.EXTERNAL, yytext()); }
"ordering"               { return symbol(XSPARQL.ORDERING, yytext()); }
"copy-namespaces"        { return symbol(XSPARQL.COPYNAMESPACES, yytext()); }
"xquery"                 { return symbol(XSPARQL.XQUERY, yytext()); }
"version"                { return symbol(XSPARQL.VERSION, yytext()); }
"encoding"               { return symbol(XSPARQL.ENCODING, yytext()); }
"lax"                    { return symbol(XSPARQL.LAX, yytext()); }
"case"                   { return symbol(XSPARQL.CASE, yytext()); }
"every"                  { return symbol(XSPARQL.EVERY, yytext()); }
"typeswitch"             { return symbol(XSPARQL.TYPESWITCH, yytext()); }
"satisfies"              { return symbol(XSPARQL.SATISFIES, yytext()); }
"validate"               { return symbol(XSPARQL.VALIDATE, yytext()); }
"some"                   { return symbol(XSPARQL.SOME, yytext()); }
"strict"                 { return symbol(XSPARQL.STRICT, yytext()); }

}

<SPARQL_WHERE, SPARQL_CONSTRUCT> 
{

"asc"                    { return symbol(XSPARQL.ASC, yytext()); }
"desc"                   { return symbol(XSPARQL.DESC, yytext()); }

}


/* -----------------Lexer rules Section----------------- */


<YYINITIAL, SPARQL_WHERE, SPARQL_CONSTRUCT, xmlStartTag, xmlEndTag> 
{

  _:{PN_PREFIX}  { return symbol(XSPARQL.BLANK_NODE_LABEL, yytext()); }

  _:({PN_PREFIX})?/\{ { return symbol(XSPARQL.BNODE_CONSTRUCT, yytext()); }

  {PN_PREFIX}?:{PN_LOCAL} { return symbol(XSPARQL.PNAME_LN, yytext()); }
  
  {PN_PREFIX}?:/[^\:\{] { return symbol(XSPARQL.PNAME_NS, yytext()); }

  {PN_PREFIX}    { return symbol(XSPARQL.NCNAME, yytext()); }

}

<YYINITIAL, xmlElementContents, SPARQL_WHERE, SPARQL_CONSTRUCT>
   {var}          { return symbol(XSPARQL.VAR, yytext()); }

<YYINITIAL, xmlElementContents, xmlStartTag, XQueryComment>
   "(:"           { pushStateAndSwitch(XQueryComment); }

<XQueryComment>  {
   [^(\(\:)(\:\))]* { /* skip XQueryComment */ }

   [:\(\)]        { /* skip XQueryComment */ }

   ":)"           { popState(); }
}


<YYINITIAL, xmlElementContents>
   <\/            { switchState(xmlEndTag);
                    return symbol(XSPARQL.ENDELM, yytext()); }


<YYINITIAL, xmlElementContents>
   \>             { return symbol(XSPARQL.GREATERTHAN, yytext()); }


<YYINITIAL, xmlStartTag, xmlEndTag, xmlElementContents, SPARQL_CONSTRUCT, SPARQL_WHERE>
   \}             { popState();
                    return symbol(XSPARQL.RCURLY, yytext()); }


<YYINITIAL, xmlStartTag, xmlEndTag, xmlElementContents>
   \{             { pushStateAndSwitch(YYINITIAL);
                    return symbol(XSPARQL.LCURLY, yytext()); }



<YYINITIAL, xmlStartTag, xmlEndTag, xmlElementContents, SPARQL_CONSTRUCT, SPARQL_WHERE> {

   \#.*           { /* ignore comments */ }

   \}>            { popState();
                    return symbol(XSPARQL.RCURLYGREATERTHAN, yytext());}
}


<xmlStartTag> {

   \>             { switchState(xmlElementContents);
                    return symbol(XSPARQL.GREATERTHAN, yytext()); }

   \/\>           { popState();
                    return symbol(XSPARQL.ENDTAG, yytext()); }
}


<xmlEndTag> {

   \>             { popState();
                    return symbol(XSPARQL.GREATERTHAN, yytext()); }
}


<xmlElementContents> {

   "<![CDATA["    { pushStateAndSwitch(cdata);
                    return symbol(XSPARQL.CDATASTART, yytext()); }



   [^\{\}\<(\(\:)]+ { return symbol(XSPARQL.NCNAMEELM, yytext()); }

}


<cdata> {
   (.|\n|\t|\r)*\]\]> { popState();
                    return symbol(XSPARQL.CDATAELMEND, yytext()); }
}

/* ------------------------- WHITESPACE ------------------------------------- */


<xmlStartTag, xmlElementContents, xmlEndTag>
   {WhiteSpace}+  { return symbol(XSPARQL.WHITESPACE, yytext()); }


<YYINITIAL, SPARQL, SPARQL_PRE_WHERE, SPARQL_PRE_CONSTRUCT, SPARQL_WHERE, SPARQL_CONSTRUCT>
   {WhiteSpace}+  { /* skip whitespace */ }


/* ------------------------- SPARQL ----------------------------------------- */

<SPARQL> {
   {iri}          {  popState();
                     return symbol(XSPARQL.IRIREF, yytext().substring(1, yytext().length()-1)); }

   {PN_PREFIX}?:/[^\:\{]
                  { return symbol(XSPARQL.PNAME_NS, yytext()); }

   "named"        { return symbol(XSPARQL.NAMED, yytext()); }
}

<SPARQL, SPARQL_WHERE, SPARQL_CONSTRUCT>
   {var}          { popState();
                    return symbol(XSPARQL.VAR, yytext()); }

<SPARQL_PRE_WHERE>
   \{             { switchState(SPARQL_WHERE);
                    return symbol(XSPARQL.LCURLY, yytext()); }


<SPARQL_PRE_CONSTRUCT>
   \{             { switchState(SPARQL_CONSTRUCT);
                    return symbol(XSPARQL.LCURLY, yytext()); }


<SPARQL_WHERE> {
   {iri}          { return symbol(XSPARQL.IRIREF, yytext()); }

   \{             { pushStateAndSwitch(SPARQL_WHERE);
                    return symbol(XSPARQL.LCURLY, yytext()); }

   \>             { return symbol(XSPARQL.GREATERTHAN, yytext()); }
}

<SPARQL_CONSTRUCT> {
   {iri}   { return symbol(XSPARQL.IRIREF, yytext()); }

   \{             { pushStateAndSwitch(YYINITIAL);
                    return symbol(XSPARQL.LCURLY, yytext()); }

   "<{"           { pushStateAndSwitch(YYINITIAL);
                    return symbol(XSPARQL.LESSTHANLCURLY,yytext()); }
}


/* No token was found for the input so through an error.  Print out an
   Illegal character message with the illegal character that was found. */
<YYINITIAL, xmlStartTag, xmlEndTag, xmlElementContents, SPARQL, SPARQL_PRE_WHERE, SPARQL_WHERE, SPARQL_PRE_CONSTRUCT, SPARQL_CONSTRUCT, XQueryComment, XQueryComment>
   [^]            { throw new Error("Illegal character <" + (yyline+1) + ":" + (yycolumn+1) + ">  \""+yytext()+"\""); }

